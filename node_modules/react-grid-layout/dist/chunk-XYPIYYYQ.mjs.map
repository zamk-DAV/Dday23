{"version":3,"sources":["../src/core/constraints.ts","../src/core/position.ts","../src/core/types.ts","../src/core/compactors.ts","../src/core/responsive.ts"],"names":[],"mappings":"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","file":"chunk-XYPIYYYQ.mjs","sourcesContent":["/**\n * Pluggable layout constraints for react-grid-layout v2\n *\n * Constraints control position and size limits during drag/resize operations.\n * They are composable, tree-shakeable, and can be applied at grid or item level.\n */\n\nimport type {\n  LayoutItem,\n  LayoutConstraint,\n  ConstraintContext,\n  ResizeHandleAxis\n} from \"./types.js\";\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Clamp a value between min and max bounds.\n */\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(max, value));\n}\n\n// ============================================================================\n// Built-in Constraints\n// ============================================================================\n\n/**\n * Grid boundary constraint.\n *\n * Ensures items stay within the grid bounds (0 to cols-w for x, 0 to maxRows-h for y).\n * This is the default position constraint.\n */\nexport const gridBounds: LayoutConstraint = {\n  name: \"gridBounds\",\n\n  constrainPosition(\n    item: LayoutItem,\n    x: number,\n    y: number,\n    { cols, maxRows }: ConstraintContext\n  ): { x: number; y: number } {\n    return {\n      x: clamp(x, 0, Math.max(0, cols - item.w)),\n      y: clamp(y, 0, Math.max(0, maxRows - item.h))\n    };\n  },\n\n  constrainSize(\n    item: LayoutItem,\n    w: number,\n    h: number,\n    handle: ResizeHandleAxis,\n    { cols, maxRows }: ConstraintContext\n  ): { w: number; h: number } {\n    // For west-side resizes (w, nw, sw), max width is limited by the right edge position\n    // because the item expands leftward (x decreases as w increases)\n    const maxW =\n      handle === \"w\" || handle === \"nw\" || handle === \"sw\"\n        ? item.x + item.w // right edge = x + w, can expand left to x=0\n        : cols - item.x; // can expand right to cols\n\n    // For north-side resizes (n, nw, ne), max height is limited by the bottom edge position\n    // because the item expands upward (y decreases as h increases)\n    const maxH =\n      handle === \"n\" || handle === \"nw\" || handle === \"ne\"\n        ? item.y + item.h // bottom edge = y + h, can expand up to y=0\n        : maxRows - item.y; // can expand down to maxRows\n\n    return {\n      w: clamp(w, 1, Math.max(1, maxW)),\n      h: clamp(h, 1, Math.max(1, maxH))\n    };\n  }\n};\n\n/**\n * Min/max size constraint.\n *\n * Enforces per-item minW/maxW/minH/maxH properties.\n * This is applied by default after gridBounds.\n */\nexport const minMaxSize: LayoutConstraint = {\n  name: \"minMaxSize\",\n\n  constrainSize(\n    item: LayoutItem,\n    w: number,\n    h: number\n  ): { w: number; h: number } {\n    return {\n      w: clamp(w, item.minW ?? 1, item.maxW ?? Infinity),\n      h: clamp(h, item.minH ?? 1, item.maxH ?? Infinity)\n    };\n  }\n};\n\n/**\n * Container bounds constraint.\n *\n * Constrains items to stay within the visible container.\n * Use this as a replacement for the legacy `isBounded` prop.\n *\n * Unlike gridBounds which uses maxRows (which may be Infinity),\n * this constraint calculates visible rows from the actual container height.\n * Falls back to maxRows if containerHeight is 0 (auto-height grids).\n */\nexport const containerBounds: LayoutConstraint = {\n  name: \"containerBounds\",\n\n  constrainPosition(\n    item: LayoutItem,\n    x: number,\n    y: number,\n    { cols, maxRows, containerHeight, rowHeight, margin }: ConstraintContext\n  ): { x: number; y: number } {\n    // Calculate visible rows from container height\n    // Formula: containerHeight = rows * rowHeight + (rows - 1) * margin\n    // Solving: rows = (containerHeight + margin) / (rowHeight + margin)\n    const visibleRows =\n      containerHeight > 0\n        ? Math.floor((containerHeight + margin[1]) / (rowHeight + margin[1]))\n        : maxRows;\n\n    return {\n      x: clamp(x, 0, Math.max(0, cols - item.w)),\n      y: clamp(y, 0, Math.max(0, visibleRows - item.h))\n    };\n  }\n};\n\n/**\n * Bounded X constraint.\n *\n * Only constrains horizontal position (x-axis).\n * Items can move freely in the vertical direction.\n */\nexport const boundedX: LayoutConstraint = {\n  name: \"boundedX\",\n\n  constrainPosition(\n    item: LayoutItem,\n    x: number,\n    y: number,\n    { cols }: ConstraintContext\n  ): { x: number; y: number } {\n    return {\n      x: clamp(x, 0, Math.max(0, cols - item.w)),\n      y\n    };\n  }\n};\n\n/**\n * Bounded Y constraint.\n *\n * Only constrains vertical position (y-axis).\n * Items can move freely in the horizontal direction.\n */\nexport const boundedY: LayoutConstraint = {\n  name: \"boundedY\",\n\n  constrainPosition(\n    item: LayoutItem,\n    x: number,\n    y: number,\n    { maxRows }: ConstraintContext\n  ): { x: number; y: number } {\n    return {\n      x,\n      y: clamp(y, 0, Math.max(0, maxRows - item.h))\n    };\n  }\n};\n\n// ============================================================================\n// Constraint Factories\n// ============================================================================\n\n/**\n * Create an aspect ratio constraint.\n *\n * Maintains a fixed width-to-height ratio **in pixels** during resize operations.\n * Accounts for the different pixel sizes of grid columns vs rows.\n *\n * @param ratio - Width-to-height ratio (e.g., 16/9 for widescreen, 1 for square)\n * @returns A constraint that enforces the aspect ratio\n *\n * @example\n * ```typescript\n * // 16:9 aspect ratio (actual pixel proportions)\n * const layout = [\n *   { i: 'video', x: 0, y: 0, w: 4, h: 2, constraints: [aspectRatio(16/9)] }\n * ];\n *\n * // Square items (in pixels, not grid units)\n * <GridLayout constraints={[gridBounds, minMaxSize, aspectRatio(1)]} />\n * ```\n */\nexport function aspectRatio(ratio: number): LayoutConstraint {\n  return {\n    name: `aspectRatio(${ratio})`,\n\n    constrainSize(\n      _item: LayoutItem,\n      w: number,\n      _h: number,\n      _handle: ResizeHandleAxis,\n      context: ConstraintContext\n    ): { w: number; h: number } {\n      const { cols, containerWidth, rowHeight, margin } = context;\n      // Calculate column width in pixels\n      // colWidth = (containerWidth - margin[0] * (cols - 1)) / cols\n      // Note: simplified formula assumes no container padding\n      const colWidth = (containerWidth - margin[0] * (cols - 1)) / cols;\n\n      // Calculate pixel width of the item\n      // pixelWidth = colWidth * w + margin[0] * (w - 1)\n      const pixelWidth = colWidth * w + margin[0] * Math.max(0, w - 1);\n\n      // Calculate required pixel height for aspect ratio\n      const pixelHeight = pixelWidth / ratio;\n\n      // Convert pixel height back to grid units\n      // pixelHeight = rowHeight * h + margin[1] * (h - 1)\n      // Solving for h:\n      // pixelHeight = h * (rowHeight + margin[1]) - margin[1]\n      // h = (pixelHeight + margin[1]) / (rowHeight + margin[1])\n      const h = Math.max(\n        1,\n        Math.round((pixelHeight + margin[1]) / (rowHeight + margin[1]))\n      );\n\n      return { w, h };\n    }\n  };\n}\n\n/**\n * Create a snap-to-grid constraint.\n *\n * Snaps positions to multiples of the specified step values.\n * Useful for aligning items to a coarser grid.\n *\n * @param stepX - Horizontal snap step in grid units\n * @param stepY - Vertical snap step in grid units (defaults to stepX)\n * @returns A constraint that snaps positions to the grid\n *\n * @example\n * ```typescript\n * // Snap to every 2 grid units\n * <GridLayout constraints={[snapToGrid(2), gridBounds]} />\n *\n * // Different horizontal and vertical snap\n * <GridLayout constraints={[snapToGrid(2, 3), gridBounds]} />\n * ```\n */\nexport function snapToGrid(\n  stepX: number,\n  stepY: number = stepX\n): LayoutConstraint {\n  // Validate step values to prevent division by zero or invalid snapping\n  if (stepX <= 0 || stepY <= 0) {\n    throw new Error(\n      `snapToGrid: step values must be positive (got stepX=${stepX}, stepY=${stepY})`\n    );\n  }\n\n  return {\n    name: `snapToGrid(${stepX}, ${stepY})`,\n\n    constrainPosition(\n      _item: LayoutItem,\n      x: number,\n      y: number\n    ): { x: number; y: number } {\n      return {\n        x: Math.round(x / stepX) * stepX,\n        y: Math.round(y / stepY) * stepY\n      };\n    }\n  };\n}\n\n/**\n * Create a minimum size constraint.\n *\n * Sets minimum width and height for all items using this constraint.\n * Useful for grid-wide minimums without setting minW/minH on each item.\n *\n * @param minW - Minimum width in grid units\n * @param minH - Minimum height in grid units\n * @returns A constraint that enforces minimum size\n */\nexport function minSize(minW: number, minH: number): LayoutConstraint {\n  return {\n    name: `minSize(${minW}, ${minH})`,\n\n    constrainSize(\n      _item: LayoutItem,\n      w: number,\n      h: number\n    ): { w: number; h: number } {\n      return {\n        w: Math.max(minW, w),\n        h: Math.max(minH, h)\n      };\n    }\n  };\n}\n\n/**\n * Create a maximum size constraint.\n *\n * Sets maximum width and height for all items using this constraint.\n * Useful for grid-wide maximums without setting maxW/maxH on each item.\n *\n * @param maxW - Maximum width in grid units\n * @param maxH - Maximum height in grid units\n * @returns A constraint that enforces maximum size\n */\nexport function maxSize(maxW: number, maxH: number): LayoutConstraint {\n  return {\n    name: `maxSize(${maxW}, ${maxH})`,\n\n    constrainSize(\n      _item: LayoutItem,\n      w: number,\n      h: number\n    ): { w: number; h: number } {\n      return {\n        w: Math.min(maxW, w),\n        h: Math.min(maxH, h)\n      };\n    }\n  };\n}\n\n// ============================================================================\n// Default Constraints\n// ============================================================================\n\n/**\n * Default constraints applied when none are specified.\n *\n * Includes:\n * - gridBounds: Keep items within the grid\n * - minMaxSize: Respect per-item min/max constraints\n */\nexport const defaultConstraints: LayoutConstraint[] = [gridBounds, minMaxSize];\n\n// ============================================================================\n// Constraint Application Functions\n// ============================================================================\n\n/**\n * Apply position constraints to a proposed position.\n *\n * Constraints are applied in array order, allowing composition.\n * Grid-level constraints are applied first, then per-item constraints.\n *\n * @param constraints - Array of constraints to apply\n * @param item - The layout item being positioned\n * @param x - Proposed x position\n * @param y - Proposed y position\n * @param context - Grid context (cols, maxRows, etc.)\n * @returns Constrained position\n */\nexport function applyPositionConstraints(\n  constraints: LayoutConstraint[],\n  item: LayoutItem,\n  x: number,\n  y: number,\n  context: ConstraintContext\n): { x: number; y: number } {\n  let result = { x, y };\n\n  // Apply grid-level constraints\n  for (const constraint of constraints) {\n    if (constraint.constrainPosition) {\n      result = constraint.constrainPosition(item, result.x, result.y, context);\n    }\n  }\n\n  // Apply per-item constraints\n  if (item.constraints) {\n    for (const constraint of item.constraints) {\n      if (constraint.constrainPosition) {\n        result = constraint.constrainPosition(\n          item,\n          result.x,\n          result.y,\n          context\n        );\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Apply size constraints to a proposed size.\n *\n * Constraints are applied in array order, allowing composition.\n * Grid-level constraints are applied first, then per-item constraints.\n *\n * @param constraints - Array of constraints to apply\n * @param item - The layout item being resized\n * @param w - Proposed width\n * @param h - Proposed height\n * @param handle - Which resize handle is being used\n * @param context - Grid context (cols, maxRows, etc.)\n * @returns Constrained size\n */\nexport function applySizeConstraints(\n  constraints: LayoutConstraint[],\n  item: LayoutItem,\n  w: number,\n  h: number,\n  handle: ResizeHandleAxis,\n  context: ConstraintContext\n): { w: number; h: number } {\n  let result = { w, h };\n\n  // Apply grid-level constraints\n  for (const constraint of constraints) {\n    if (constraint.constrainSize) {\n      result = constraint.constrainSize(\n        item,\n        result.w,\n        result.h,\n        handle,\n        context\n      );\n    }\n  }\n\n  // Apply per-item constraints\n  if (item.constraints) {\n    for (const constraint of item.constraints) {\n      if (constraint.constrainSize) {\n        result = constraint.constrainSize(\n          item,\n          result.w,\n          result.h,\n          handle,\n          context\n        );\n      }\n    }\n  }\n\n  return result;\n}\n","/**\n * Position calculation utilities.\n *\n * These functions convert between grid units and pixel positions,\n * and generate CSS styles for grid items.\n */\n\nimport type {\n  Position,\n  PartialPosition,\n  ResizeHandleAxis,\n  PositionStrategy\n} from \"./types.js\";\n\n// ============================================================================\n// CSS Style Generation\n// ============================================================================\n\n/**\n * Generate CSS transform-based positioning styles.\n *\n * Using transforms is more performant than top/left positioning\n * because it doesn't trigger layout recalculations.\n *\n * @param position - Position in pixels\n * @returns CSS style object\n */\nexport function setTransform({\n  top,\n  left,\n  width,\n  height\n}: Position): Record<string, string> {\n  const translate = `translate(${left}px,${top}px)`;\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Generate CSS top/left positioning styles.\n *\n * Use this when transforms are not suitable (e.g., for printing\n * or when transform causes issues with child elements).\n *\n * @param position - Position in pixels\n * @returns CSS style object\n */\nexport function setTopLeft({\n  top,\n  left,\n  width,\n  height\n}: Position): Record<string, string> {\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Convert a number to a percentage string.\n *\n * @param num - Number to convert (0-1 range typically)\n * @returns Percentage string (e.g., \"50%\")\n */\nexport function perc(num: number): string {\n  return num * 100 + \"%\";\n}\n\n// ============================================================================\n// Resize Direction Handling\n// ============================================================================\n\n/**\n * Constrain width to not overflow container.\n */\nfunction constrainWidth(\n  left: number,\n  currentWidth: number,\n  newWidth: number,\n  containerWidth: number\n): number {\n  return left + newWidth > containerWidth ? currentWidth : newWidth;\n}\n\n/**\n * Constrain height to not go above container (negative top).\n */\nfunction constrainHeight(\n  top: number,\n  currentHeight: number,\n  newHeight: number\n): number {\n  return top < 0 ? currentHeight : newHeight;\n}\n\n/**\n * Constrain left to not be negative.\n */\nfunction constrainLeft(left: number): number {\n  return Math.max(0, left);\n}\n\n/**\n * Constrain top to not be negative.\n */\nfunction constrainTop(top: number): number {\n  return Math.max(0, top);\n}\n\n// Direction handlers\ntype ResizeHandler = (\n  currentSize: Position,\n  newSize: Position,\n  containerWidth: number\n) => Position;\n\nconst resizeNorth: ResizeHandler = (currentSize, newSize, _containerWidth) => {\n  const { left, height, width } = newSize;\n  const top = currentSize.top - (height - currentSize.height);\n\n  return {\n    left,\n    width,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\n\nconst resizeEast: ResizeHandler = (currentSize, newSize, containerWidth) => {\n  const { top, left, height, width } = newSize;\n  return {\n    top,\n    height,\n    width: constrainWidth(\n      currentSize.left,\n      currentSize.width,\n      width,\n      containerWidth\n    ),\n    left: constrainLeft(left)\n  };\n};\n\nconst resizeWest: ResizeHandler = (currentSize, newSize, _containerWidth) => {\n  const { top, height, width } = newSize;\n  const left = currentSize.left + currentSize.width - width;\n\n  if (left < 0) {\n    return {\n      height,\n      width: currentSize.left + currentSize.width,\n      top: constrainTop(top),\n      left: 0\n    };\n  }\n\n  return {\n    height,\n    width,\n    top: constrainTop(top),\n    left\n  };\n};\n\nconst resizeSouth: ResizeHandler = (currentSize, newSize, _containerWidth) => {\n  const { top, left, height, width } = newSize;\n  return {\n    width,\n    left,\n    height: constrainHeight(top, currentSize.height, height),\n    top: constrainTop(top)\n  };\n};\n\n// Compound directions (corners)\nconst resizeNorthEast: ResizeHandler = (currentSize, newSize, containerWidth) =>\n  resizeNorth(\n    currentSize,\n    resizeEast(currentSize, newSize, containerWidth),\n    containerWidth\n  );\n\nconst resizeNorthWest: ResizeHandler = (currentSize, newSize, containerWidth) =>\n  resizeNorth(\n    currentSize,\n    resizeWest(currentSize, newSize, containerWidth),\n    containerWidth\n  );\n\nconst resizeSouthEast: ResizeHandler = (currentSize, newSize, containerWidth) =>\n  resizeSouth(\n    currentSize,\n    resizeEast(currentSize, newSize, containerWidth),\n    containerWidth\n  );\n\nconst resizeSouthWest: ResizeHandler = (currentSize, newSize, containerWidth) =>\n  resizeSouth(\n    currentSize,\n    resizeWest(currentSize, newSize, containerWidth),\n    containerWidth\n  );\n\nconst resizeHandlerMap: Record<ResizeHandleAxis, ResizeHandler> = {\n  n: resizeNorth,\n  ne: resizeNorthEast,\n  e: resizeEast,\n  se: resizeSouthEast,\n  s: resizeSouth,\n  sw: resizeSouthWest,\n  w: resizeWest,\n  nw: resizeNorthWest\n};\n\n/**\n * Resize an item in a specific direction, clamping to container bounds.\n *\n * This handles the complex logic of resizing from different edges/corners,\n * ensuring the item doesn't overflow the container.\n *\n * @param direction - Which edge/corner is being dragged\n * @param currentSize - Current position and size\n * @param newSize - Requested new position and size\n * @param containerWidth - Width of the container\n * @returns Constrained position and size\n */\nexport function resizeItemInDirection(\n  direction: ResizeHandleAxis,\n  currentSize: Position,\n  newSize: Position,\n  containerWidth: number\n): Position {\n  const handler = resizeHandlerMap[direction];\n\n  // Fallback if direction not found (shouldn't happen with proper types)\n  if (!handler) {\n    return newSize;\n  }\n\n  return handler(currentSize, { ...currentSize, ...newSize }, containerWidth);\n}\n\n// ============================================================================\n// Position Strategies (v2 Composable Interface)\n// ============================================================================\n\n/**\n * CSS transform-based positioning strategy.\n *\n * Uses CSS transforms for positioning, which is more performant\n * as it doesn't trigger layout recalculations.\n *\n * This is the default strategy.\n */\nexport const transformStrategy: PositionStrategy = {\n  type: \"transform\",\n  scale: 1,\n\n  calcStyle(pos: Position): React.CSSProperties {\n    return setTransform(pos) as React.CSSProperties;\n  }\n};\n\n/**\n * Absolute (top/left) positioning strategy.\n *\n * Uses CSS top/left for positioning. Use this when CSS transforms\n * cause issues (e.g., printing, certain child element positioning).\n */\nexport const absoluteStrategy: PositionStrategy = {\n  type: \"absolute\",\n  scale: 1,\n\n  calcStyle(pos: Position): React.CSSProperties {\n    return setTopLeft(pos) as React.CSSProperties;\n  }\n};\n\n/**\n * Create a scaled transform strategy.\n *\n * Use this when the grid container is inside a scaled element\n * (e.g., `transform: scale(0.5)`). The scale factor adjusts\n * drag/resize calculations to account for the parent transform.\n *\n * @param scale - Scale factor (e.g., 0.5 for half size)\n * @returns Position strategy with scaled calculations\n *\n * @example\n * ```tsx\n * <div style={{ transform: 'scale(0.5)' }}>\n *   <GridLayout positionStrategy={createScaledStrategy(0.5)} />\n * </div>\n * ```\n */\nexport function createScaledStrategy(scale: number): PositionStrategy {\n  return {\n    type: \"transform\",\n    scale,\n\n    calcStyle(pos: Position): React.CSSProperties {\n      return setTransform(pos) as React.CSSProperties;\n    },\n\n    calcDragPosition(\n      clientX: number,\n      clientY: number,\n      offsetX: number,\n      offsetY: number\n    ): PartialPosition {\n      return {\n        left: (clientX - offsetX) / scale,\n        top: (clientY - offsetY) / scale\n      };\n    }\n  };\n}\n\n/** Default position strategy (transform-based) */\nexport const defaultPositionStrategy = transformStrategy;\n","/**\n * Core types for react-grid-layout v2\n *\n * These types are framework-agnostic and define the data structures\n * used by the layout algorithms.\n */\n\n// ============================================================================\n// Resize Handle Types\n// ============================================================================\n\n/**\n * Axis identifiers for resize handles.\n * - Cardinal: 'n', 's', 'e', 'w' (north, south, east, west)\n * - Diagonal: 'ne', 'nw', 'se', 'sw'\n */\nexport type ResizeHandleAxis =\n  | \"s\"\n  | \"w\"\n  | \"e\"\n  | \"n\"\n  | \"sw\"\n  | \"nw\"\n  | \"se\"\n  | \"ne\";\n\n// ============================================================================\n// Layout Item Types\n// ============================================================================\n\n/**\n * A single item in the grid layout.\n *\n * Position (x, y) is in grid units, not pixels.\n * Size (w, h) is in grid units.\n */\nexport interface LayoutItem {\n  /** Unique identifier for this item */\n  i: string;\n\n  /** X position in grid units (0-indexed from left) */\n  x: number;\n\n  /** Y position in grid units (0-indexed from top) */\n  y: number;\n\n  /** Width in grid units */\n  w: number;\n\n  /** Height in grid units */\n  h: number;\n\n  /** Minimum width in grid units */\n  minW?: number;\n\n  /** Minimum height in grid units */\n  minH?: number;\n\n  /** Maximum width in grid units */\n  maxW?: number;\n\n  /** Maximum height in grid units */\n  maxH?: number;\n\n  /**\n   * If true, item cannot be dragged or resized, and other items\n   * will move around it during compaction.\n   */\n  static?: boolean;\n\n  /**\n   * If false, item cannot be dragged (but may still be resizable).\n   * Overrides grid-level isDraggable for this item.\n   */\n  isDraggable?: boolean;\n\n  /**\n   * If false, item cannot be resized (but may still be draggable).\n   * Overrides grid-level isResizable for this item.\n   */\n  isResizable?: boolean;\n\n  /**\n   * Which resize handles to show for this item.\n   * Overrides grid-level resizeHandles for this item.\n   */\n  resizeHandles?: ResizeHandleAxis[];\n\n  /**\n   * If true, item is constrained to the grid container bounds.\n   * Overrides grid-level isBounded for this item.\n   */\n  isBounded?: boolean;\n\n  /**\n   * Internal flag set during drag/resize operations to indicate\n   * the item has moved from its original position.\n   * @internal\n   */\n  moved?: boolean;\n\n  /**\n   * Per-item layout constraints.\n   * Applied in addition to grid-level constraints.\n   */\n  constraints?: LayoutConstraint[];\n}\n\n/**\n * A layout is a readonly array of layout items.\n * Layouts should be treated as immutable.\n */\nexport type Layout = readonly LayoutItem[];\n\n// ============================================================================\n// Position & Size Types\n// ============================================================================\n\n/**\n * Pixel position and size of an element.\n */\nexport interface Position {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n}\n\n/**\n * Partial position (just coordinates, no size).\n */\nexport interface PartialPosition {\n  left: number;\n  top: number;\n}\n\n/**\n * Size in pixels.\n */\nexport interface Size {\n  width: number;\n  height: number;\n}\n\n/**\n * Position when dropping an external element onto the grid.\n */\nexport interface DroppingPosition {\n  left: number;\n  top: number;\n  e: Event;\n}\n\n// ============================================================================\n// Event Types\n// ============================================================================\n\n/**\n * Data provided by react-draggable during drag operations.\n */\nexport interface ReactDraggableCallbackData {\n  node: HTMLElement;\n  x?: number;\n  y?: number;\n  deltaX: number;\n  deltaY: number;\n  lastX?: number;\n  lastY?: number;\n}\n\n/**\n * Grid-level drag event data.\n */\nexport interface GridDragEvent {\n  e: Event;\n  node: HTMLElement;\n  newPosition: PartialPosition;\n}\n\n/**\n * Grid-level resize event data.\n */\nexport interface GridResizeEvent {\n  e: Event;\n  node: HTMLElement;\n  size: Size;\n  handle: ResizeHandleAxis;\n}\n\n/**\n * Drag-over event with layer coordinates.\n */\nexport interface DragOverEvent extends MouseEvent {\n  nativeEvent: Event & {\n    layerX: number;\n    layerY: number;\n  };\n}\n\n// ============================================================================\n// Compaction Types\n// ============================================================================\n\n/**\n * Type of compaction to apply to the layout.\n * - 'vertical': Items compact upward (default)\n * - 'horizontal': Items compact leftward\n * - 'wrap': Items arranged in wrapped-paragraph style (like words in text)\n * - null: No compaction (free-form positioning)\n */\nexport type CompactType = \"horizontal\" | \"vertical\" | \"wrap\" | null;\n\n// ============================================================================\n// Callback Types\n// ============================================================================\n\n/**\n * Standard callback signature for layout change events.\n *\n * @param layout - The current layout after the change\n * @param oldItem - The item before the change (null if not applicable)\n * @param newItem - The item after the change (null if not applicable)\n * @param placeholder - The placeholder item during drag/resize (null at start)\n * @param event - The DOM event that triggered the change\n * @param element - The DOM element being manipulated (null if not applicable)\n */\nexport type EventCallback = (\n  layout: Layout,\n  oldItem: LayoutItem | null,\n  newItem: LayoutItem | null,\n  placeholder: LayoutItem | null,\n  event: Event,\n  element: HTMLElement | null\n) => void;\n\n/**\n * Callback when layout changes for any reason.\n */\nexport type OnLayoutChangeCallback = (layout: Layout) => void;\n\n// ============================================================================\n// Composable Interfaces (v2 API)\n// ============================================================================\n\n/**\n * Interface for layout compaction strategies.\n *\n * Implement this interface to create custom compaction algorithms.\n *\n * @example\n * ```typescript\n * const myCompactor: Compactor = {\n *   type: 'vertical',\n *   allowOverlap: false,\n *   compact(layout, cols) {\n *     // Custom compaction logic\n *     return compactedLayout;\n *   }\n * };\n * ```\n */\nexport interface Compactor {\n  /** Compaction type identifier */\n  readonly type: CompactType;\n\n  /**\n   * Whether items can overlap (stack on top of each other).\n   *\n   * When true:\n   * - Items can be placed on top of other items\n   * - Dragging into another item does NOT push it away\n   * - Compaction is skipped after drag/resize\n   */\n  readonly allowOverlap: boolean;\n\n  /**\n   * Whether to block movement that would cause collision.\n   *\n   * When true (and allowOverlap is false):\n   * - Dragging into another item is blocked (item snaps back)\n   * - Other items are NOT pushed away\n   * - Only affects drag/resize, not compaction\n   *\n   * Has no effect when allowOverlap is true.\n   */\n  readonly preventCollision?: boolean;\n\n  /**\n   * Compact the layout.\n   *\n   * @param layout - The layout to compact\n   * @param cols - Number of columns in the grid\n   * @returns The compacted layout\n   */\n  compact(layout: Layout, cols: number): Layout;\n}\n\n/**\n * Interface for CSS positioning strategies.\n *\n * Implement this interface to customize how items are positioned in the DOM.\n * Built-in strategies: transformStrategy, absoluteStrategy.\n *\n * @example\n * ```typescript\n * // Use transform-based positioning (default, better performance)\n * <GridLayout positionStrategy={transformStrategy} />\n *\n * // Use top/left positioning (for environments where transforms cause issues)\n * <GridLayout positionStrategy={absoluteStrategy} />\n *\n * // Use scaled transforms (for scaled containers)\n * <GridLayout positionStrategy={createScaledStrategy(0.5)} />\n * ```\n */\nexport interface PositionStrategy {\n  /** Strategy type identifier */\n  readonly type: \"transform\" | \"absolute\";\n\n  /** Scale factor for drag/resize calculations */\n  readonly scale: number;\n\n  /**\n   * Convert pixel position to CSS style object.\n   *\n   * @param pos - Position in pixels\n   * @returns CSS properties for positioning the element\n   */\n  calcStyle(pos: Position): React.CSSProperties;\n\n  /**\n   * Calculate position during drag operations, accounting for transforms and scale.\n   *\n   * This method is optional. When not provided, react-draggable uses its built-in\n   * parent-relative coordinate calculation. Only override this when you need custom\n   * coordinate handling, such as for scaled containers.\n   *\n   * @param clientX - Mouse client X position\n   * @param clientY - Mouse client Y position\n   * @param offsetX - Offset from element origin X\n   * @param offsetY - Offset from element origin Y\n   * @returns Adjusted left/top position\n   */\n  calcDragPosition?(\n    clientX: number,\n    clientY: number,\n    offsetX: number,\n    offsetY: number\n  ): PartialPosition;\n}\n\n// ============================================================================\n// Layout Constraint Types\n// ============================================================================\n\n/**\n * Context provided to constraint functions during drag/resize operations.\n */\nexport interface ConstraintContext {\n  /** Number of columns in the grid */\n  cols: number;\n\n  /** Maximum number of rows (Infinity if unbounded) */\n  maxRows: number;\n\n  /** Container width in pixels */\n  containerWidth: number;\n\n  /** Container height in pixels (may be 0 if auto-height) */\n  containerHeight: number;\n\n  /** Row height in pixels */\n  rowHeight: number;\n\n  /** Margin between items [x, y] in pixels */\n  margin: readonly [number, number];\n\n  /** Current layout state */\n  layout: Layout;\n}\n\n/**\n * Interface for layout constraints.\n *\n * Implement this interface to create custom position/size constraints.\n * Built-in constraints: gridBounds, minMaxSize, containerBounds, boundedX, boundedY.\n *\n * @example\n * ```typescript\n * // Grid-level constraints\n * <GridLayout constraints={[gridBounds, minMaxSize, aspectRatio(16/9)]} />\n *\n * // Per-item constraints\n * const layout = [\n *   { i: 'video', x: 0, y: 0, w: 4, h: 2, constraints: [aspectRatio(16/9)] }\n * ];\n * ```\n */\nexport interface LayoutConstraint {\n  /** Constraint identifier for debugging */\n  readonly name: string;\n\n  /**\n   * Constrain position during drag operations.\n   * Called after grid unit conversion, before layout update.\n   *\n   * @param item - The item being dragged\n   * @param x - Proposed x position in grid units\n   * @param y - Proposed y position in grid units\n   * @param context - Grid context (cols, maxRows, etc.)\n   * @returns Constrained x, y position\n   */\n  constrainPosition?(\n    item: LayoutItem,\n    x: number,\n    y: number,\n    context: ConstraintContext\n  ): { x: number; y: number };\n\n  /**\n   * Constrain size during resize operations.\n   * Called after grid unit conversion, before layout update.\n   *\n   * @param item - The item being resized\n   * @param w - Proposed width in grid units\n   * @param h - Proposed height in grid units\n   * @param handle - Which resize handle is being used\n   * @param context - Grid context (cols, maxRows, etc.)\n   * @returns Constrained w, h size\n   */\n  constrainSize?(\n    item: LayoutItem,\n    w: number,\n    h: number,\n    handle: ResizeHandleAxis,\n    context: ConstraintContext\n  ): { w: number; h: number };\n}\n\n// ============================================================================\n// Grid Configuration Types (v2 Composable Interfaces)\n// ============================================================================\n\n/**\n * Grid measurement configuration.\n * Groups all grid metrics (columns, row height, margins).\n */\nexport interface GridConfig {\n  /** Number of columns in the grid (default: 12) */\n  cols: number;\n\n  /** Height of a single row in pixels (default: 150) */\n  rowHeight: number;\n\n  /** [horizontal, vertical] margin between items in pixels (default: [10, 10]) */\n  margin: readonly [number, number];\n\n  /** [horizontal, vertical] padding inside the container (default: null, uses margin) */\n  containerPadding: readonly [number, number] | null;\n\n  /** Maximum number of rows (default: Infinity) */\n  maxRows: number;\n}\n\n/** Default grid configuration */\nexport const defaultGridConfig: GridConfig = {\n  cols: 12,\n  rowHeight: 150,\n  margin: [10, 10],\n  containerPadding: null,\n  maxRows: Infinity\n};\n\n/**\n * Drag behavior configuration.\n * Groups all drag-related settings.\n */\nexport interface DragConfig {\n  /** Whether items can be dragged (default: true) */\n  enabled: boolean;\n\n  /** Whether items are bounded to the container (default: false) */\n  bounded: boolean;\n\n  /** CSS selector for drag handle (e.g., '.drag-handle') */\n  handle?: string;\n\n  /** CSS selector for elements that should not trigger drag */\n  cancel?: string;\n\n  /**\n   * Minimum pixels to move before drag starts.\n   * Helps distinguish click from drag (fixes #1341, #1401).\n   * @default 3\n   */\n  threshold: number;\n}\n\n/** Default drag configuration */\nexport const defaultDragConfig: DragConfig = {\n  enabled: true,\n  bounded: false,\n  threshold: 3\n};\n\n/**\n * Resize behavior configuration.\n * Groups all resize-related settings.\n */\nexport interface ResizeConfig {\n  /** Whether items can be resized (default: true) */\n  enabled: boolean;\n\n  /** Which resize handles to show (default: ['se']) */\n  handles: readonly ResizeHandleAxis[];\n\n  /**\n   * Custom resize handle component.\n   * Can be a React node or a function that receives the axis.\n   */\n  handleComponent?:\n    | React.ReactNode\n    | ((\n        axis: ResizeHandleAxis,\n        ref: React.Ref<HTMLElement>\n      ) => React.ReactNode);\n}\n\n/** Default resize configuration */\nexport const defaultResizeConfig: ResizeConfig = {\n  enabled: true,\n  handles: [\"se\"]\n};\n\n/**\n * Drop configuration (for dropping external elements).\n * Groups all drop-related settings.\n */\nexport interface DropConfig {\n  /** Whether external elements can be dropped on the grid (default: false) */\n  enabled: boolean;\n\n  /** Default size for dropped items (default: { w: 1, h: 1 }) */\n  defaultItem: { w: number; h: number };\n\n  /**\n   * Called when dragging over the grid.\n   * Return dimensions to override defaultItem, or false to reject the drop.\n   * Can also return dragOffsetX/dragOffsetY to specify cursor offset for centering.\n   */\n  onDragOver?: (\n    e: DragEvent\n  ) =>\n    | { w?: number; h?: number; dragOffsetX?: number; dragOffsetY?: number }\n    | false\n    | void;\n}\n\n/** Default drop configuration */\nexport const defaultDropConfig: DropConfig = {\n  enabled: false,\n  defaultItem: { w: 1, h: 1 }\n};\n\n// ============================================================================\n// Responsive Types\n// ============================================================================\n\n/**\n * Breakpoint name (e.g., 'lg', 'md', 'sm', 'xs', 'xxs').\n */\nexport type Breakpoint = string;\n\n/**\n * Map of breakpoint name to pixel width.\n * Generic type B allows custom breakpoint strings.\n */\nexport type Breakpoints<B extends Breakpoint = Breakpoint> = Record<B, number>;\n\n/**\n * Map of breakpoint name to number of columns.\n * Generic type B allows custom breakpoint strings.\n */\nexport type BreakpointCols<B extends Breakpoint = Breakpoint> = Record<\n  B,\n  number\n>;\n\n/**\n * Map of breakpoint name to layout.\n * Generic type B allows custom breakpoint strings.\n */\nexport type ResponsiveLayouts<B extends Breakpoint = Breakpoint> = Partial<\n  Record<B, Layout>\n>;\n\n/**\n * Callback when breakpoint changes.\n */\nexport type OnBreakpointChangeCallback<B extends Breakpoint = Breakpoint> = (\n  newBreakpoint: B,\n  cols: number\n) => void;\n\n// ============================================================================\n// Utility Types\n// ============================================================================\n\n/**\n * Makes all properties in T mutable (removes readonly).\n */\nexport type Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Deep partial - all properties and nested properties are optional.\n */\nexport type DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];\n};\n\n/**\n * Extract the element type from an array type.\n */\nexport type ArrayElement<T> = T extends readonly (infer U)[] ? U : never;\n","/**\n * Compactor implementations.\n *\n * Compactors are pluggable strategies for removing gaps between grid items.\n * Use the Compactor interface to create custom compaction algorithms.\n */\n\nimport type {\n  Compactor,\n  CompactType,\n  Layout,\n  LayoutItem,\n  Mutable\n} from \"./types.js\";\nimport { getFirstCollision } from \"./collision.js\";\nimport { sortLayoutItemsByRowCol, sortLayoutItemsByColRow } from \"./sort.js\";\nimport { bottom, cloneLayoutItem, getStatics, cloneLayout } from \"./layout.js\";\nimport { collides } from \"./collision.js\";\n\n// ============================================================================\n// Helpers for Custom Compactors\n// ============================================================================\n\n/**\n * Resolve a compaction collision by moving items.\n *\n * Before moving an item to a position, checks if that movement would\n * cause collisions and recursively moves those items first.\n *\n * Useful for implementing custom compactors.\n *\n * @param layout - Full layout (must be sorted for optimization)\n * @param item - Item being moved (will be mutated)\n * @param moveToCoord - Target coordinate\n * @param axis - Which axis to move on ('x' or 'y')\n * @param hasStatics - Whether layout contains static items (disables early break optimization)\n */\nexport function resolveCompactionCollision(\n  layout: Layout,\n  item: LayoutItem,\n  moveToCoord: number,\n  axis: \"x\" | \"y\",\n  hasStatics?: boolean\n): void {\n  const sizeProp = axis === \"x\" ? \"w\" : \"h\";\n\n  // Temporarily increment position to check for collisions\n  (item as Mutable<LayoutItem>)[axis] += 1;\n\n  const itemIndex = layout.findIndex(l => l.i === item.i);\n\n  // Calculate hasStatics once if not provided (for backwards compat)\n  const layoutHasStatics = hasStatics ?? getStatics(layout).length > 0;\n\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i];\n    if (otherItem === undefined) continue;\n    if (otherItem.static) continue;\n    // Optimization: break early if past this element, but only if no statics\n    // are present. Static items can be scattered throughout the layout,\n    // so we can't assume sort order guarantees no more collisions.\n    if (!layoutHasStatics && otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(\n        layout,\n        otherItem,\n        moveToCoord + item[sizeProp],\n        axis,\n        layoutHasStatics\n      );\n    }\n  }\n\n  (item as Mutable<LayoutItem>)[axis] = moveToCoord;\n}\n\n/**\n * Compact a single item vertically (move up).\n *\n * Moves the item as far up as possible without colliding.\n * Useful for implementing custom vertical compactors.\n *\n * @param compareWith - Items to check for collisions\n * @param l - Item to compact (will be mutated)\n * @param fullLayout - Full layout for collision resolution\n * @param maxY - Maximum Y to start from\n * @returns The compacted item\n */\nexport function compactItemVertical(\n  compareWith: Layout,\n  l: LayoutItem,\n  fullLayout: Layout,\n  maxY: number\n): LayoutItem {\n  // Correct negative positions first\n  (l as Mutable<LayoutItem>).x = Math.max(l.x, 0);\n  (l as Mutable<LayoutItem>).y = Math.max(l.y, 0);\n\n  // Limit Y to the current bottom\n  (l as Mutable<LayoutItem>).y = Math.min(maxY, l.y);\n\n  // Move up as far as possible\n  while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n    (l as Mutable<LayoutItem>).y--;\n  }\n\n  // Resolve collisions by moving down\n  let collision: LayoutItem | undefined;\n  while ((collision = getFirstCollision(compareWith, l)) !== undefined) {\n    resolveCompactionCollision(fullLayout, l, collision.y + collision.h, \"y\");\n  }\n\n  (l as Mutable<LayoutItem>).y = Math.max(l.y, 0);\n  return l;\n}\n\n/**\n * Compact a single item horizontally (move left).\n *\n * Moves the item as far left as possible without colliding.\n * Wraps to the next row if it overflows.\n * Useful for implementing custom horizontal compactors.\n *\n * @param compareWith - Items to check for collisions\n * @param l - Item to compact (will be mutated)\n * @param cols - Number of columns in the grid\n * @param fullLayout - Full layout for collision resolution\n * @returns The compacted item\n */\nexport function compactItemHorizontal(\n  compareWith: Layout,\n  l: LayoutItem,\n  cols: number,\n  fullLayout: Layout\n): LayoutItem {\n  // Correct negative positions first\n  (l as Mutable<LayoutItem>).x = Math.max(l.x, 0);\n  (l as Mutable<LayoutItem>).y = Math.max(l.y, 0);\n\n  // Move left as far as possible\n  while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n    (l as Mutable<LayoutItem>).x--;\n  }\n\n  // Resolve collisions\n  let collision: LayoutItem | undefined;\n  while ((collision = getFirstCollision(compareWith, l)) !== undefined) {\n    resolveCompactionCollision(fullLayout, l, collision.x + collision.w, \"x\");\n\n    // Horizontal overflow: wrap to next row\n    if (l.x + l.w > cols) {\n      (l as Mutable<LayoutItem>).x = cols - l.w;\n      (l as Mutable<LayoutItem>).y++;\n\n      while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n        (l as Mutable<LayoutItem>).x--;\n      }\n    }\n  }\n\n  (l as Mutable<LayoutItem>).x = Math.max(l.x, 0);\n  return l;\n}\n\n// ============================================================================\n// Vertical Compactor\n// ============================================================================\n\n/**\n * Vertical compactor - moves items up to fill gaps.\n *\n * Items are sorted by row then column, and each item is moved\n * as far up as possible without overlapping other items.\n *\n * This is the default compaction mode for react-grid-layout.\n */\nexport const verticalCompactor: Compactor = {\n  type: \"vertical\",\n  allowOverlap: false,\n\n  compact(layout: Layout, _cols: number): Layout {\n    const compareWith = getStatics(layout);\n    let maxY = bottom(compareWith);\n    const sorted = sortLayoutItemsByRowCol(layout);\n    const out: LayoutItem[] = new Array(layout.length);\n\n    for (let i = 0; i < sorted.length; i++) {\n      const sortedItem = sorted[i];\n      if (sortedItem === undefined) continue;\n\n      let l = cloneLayoutItem(sortedItem);\n\n      if (!l.static) {\n        l = compactItemVertical(compareWith, l, sorted, maxY);\n        maxY = Math.max(maxY, l.y + l.h);\n        compareWith.push(l);\n      }\n\n      const originalIndex = layout.indexOf(sortedItem);\n      out[originalIndex] = l;\n      l.moved = false;\n    }\n\n    return out;\n  }\n};\n\n// ============================================================================\n// Horizontal Compactor\n// ============================================================================\n\n/**\n * Horizontal compactor - moves items left to fill gaps.\n *\n * Items are sorted by column then row, and each item is moved\n * as far left as possible without overlapping other items.\n */\nexport const horizontalCompactor: Compactor = {\n  type: \"horizontal\",\n  allowOverlap: false,\n\n  compact(layout: Layout, cols: number): Layout {\n    const compareWith = getStatics(layout);\n    const sorted = sortLayoutItemsByColRow(layout);\n    const out: LayoutItem[] = new Array(layout.length);\n\n    for (let i = 0; i < sorted.length; i++) {\n      const sortedItem = sorted[i];\n      if (sortedItem === undefined) continue;\n\n      let l = cloneLayoutItem(sortedItem);\n\n      if (!l.static) {\n        l = compactItemHorizontal(compareWith, l, cols, sorted);\n        compareWith.push(l);\n      }\n\n      const originalIndex = layout.indexOf(sortedItem);\n      out[originalIndex] = l;\n      l.moved = false;\n    }\n\n    return out;\n  }\n};\n\n// ============================================================================\n// No Compaction\n// ============================================================================\n\n/**\n * No compaction - items stay where placed.\n *\n * Use this for free-form layouts where items can be placed anywhere.\n * Items will not automatically move to fill gaps.\n */\nexport const noCompactor: Compactor = {\n  type: null,\n  allowOverlap: false,\n\n  compact(layout: Layout, _cols: number): Layout {\n    // No compaction - just clone to maintain immutability\n    return cloneLayout(layout);\n  }\n};\n\n// ============================================================================\n// Overlap-Allowing Variants\n// ============================================================================\n\n/**\n * Vertical compactor that allows overlapping items.\n *\n * Items compact upward but are allowed to overlap each other.\n * Useful for layered layouts or when collision detection is handled externally.\n */\nexport const verticalOverlapCompactor: Compactor = {\n  ...verticalCompactor,\n  allowOverlap: true,\n\n  compact(layout: Layout, _cols: number): Layout {\n    // With overlap allowed, just clone without moving\n    return cloneLayout(layout);\n  }\n};\n\n/**\n * Horizontal compactor that allows overlapping items.\n */\nexport const horizontalOverlapCompactor: Compactor = {\n  ...horizontalCompactor,\n  allowOverlap: true,\n\n  compact(layout: Layout, _cols: number): Layout {\n    return cloneLayout(layout);\n  }\n};\n\n/**\n * No compaction, with overlapping allowed.\n *\n * Items stay where placed and can overlap each other.\n */\nexport const noOverlapCompactor: Compactor = {\n  ...noCompactor,\n  allowOverlap: true\n};\n\n// ============================================================================\n// Factory Function\n// ============================================================================\n\n/**\n * Get a compactor by type.\n *\n * This is a convenience function for backwards compatibility with the\n * string-based compactType API.\n *\n * Note: For 'wrap' mode, import `wrapCompactor` from 'react-grid-layout/extras'\n * and pass it directly to the `compactor` prop. This function returns\n * `noCompactor` for 'wrap' type since the wrap compactor is tree-shakeable.\n *\n * @param compactType - 'vertical', 'horizontal', 'wrap', or null\n * @param allowOverlap - Whether to allow overlapping items\n * @returns The appropriate Compactor\n */\nexport function getCompactor(\n  compactType: CompactType,\n  allowOverlap: boolean = false,\n  preventCollision: boolean = false\n): Compactor {\n  let baseCompactor: Compactor;\n\n  if (allowOverlap) {\n    if (compactType === \"vertical\") baseCompactor = verticalOverlapCompactor;\n    else if (compactType === \"horizontal\")\n      baseCompactor = horizontalOverlapCompactor;\n    else baseCompactor = noOverlapCompactor;\n  } else {\n    if (compactType === \"vertical\") baseCompactor = verticalCompactor;\n    else if (compactType === \"horizontal\") baseCompactor = horizontalCompactor;\n    // For 'wrap' and null, use noCompactor\n    // Users wanting wrap mode should import wrapCompactor from extras\n    else baseCompactor = noCompactor;\n  }\n\n  // Return with preventCollision if specified\n  if (preventCollision) {\n    return { ...baseCompactor, preventCollision };\n  }\n  return baseCompactor;\n}\n","/**\n * Responsive layout utilities.\n *\n * Functions for handling responsive breakpoints and layout generation.\n */\n\nimport type {\n  Breakpoint,\n  Breakpoints,\n  Compactor,\n  CompactType,\n  Layout,\n  ResponsiveLayouts\n} from \"./types.js\";\nimport { cloneLayout, correctBounds } from \"./layout.js\";\nimport { getCompactor } from \"./compactors.js\";\n\n// ============================================================================\n// Breakpoint Utilities\n// ============================================================================\n\n/**\n * Sort breakpoints by width (ascending).\n *\n * Returns an array of breakpoint names sorted from smallest to largest.\n * E.g., ['xxs', 'xs', 'sm', 'md', 'lg']\n *\n * @param breakpoints - Map of breakpoint names to widths\n * @returns Sorted array of breakpoint names\n */\nexport function sortBreakpoints<B extends Breakpoint>(\n  breakpoints: Breakpoints<B>\n): B[] {\n  const keys = Object.keys(breakpoints) as B[];\n  return keys.sort((a, b) => breakpoints[a] - breakpoints[b]);\n}\n\n/**\n * Get the active breakpoint for a given width.\n *\n * Returns the highest breakpoint that is valid for the width (width > breakpoint).\n *\n * @param breakpoints - Map of breakpoint names to widths\n * @param width - Container width in pixels\n * @returns Active breakpoint name\n */\nexport function getBreakpointFromWidth<B extends Breakpoint>(\n  breakpoints: Breakpoints<B>,\n  width: number\n): B {\n  const sorted = sortBreakpoints(breakpoints);\n  let matching = sorted[0];\n\n  if (matching === undefined) {\n    throw new Error(\"No breakpoints defined\");\n  }\n\n  for (let i = 1; i < sorted.length; i++) {\n    const breakpointName = sorted[i];\n    if (breakpointName === undefined) continue;\n\n    const breakpointWidth = breakpoints[breakpointName];\n    if (width > breakpointWidth) {\n      matching = breakpointName;\n    }\n  }\n\n  return matching;\n}\n\n/**\n * Get the column count for a breakpoint.\n *\n * @param breakpoint - Breakpoint name\n * @param cols - Map of breakpoint names to column counts\n * @returns Number of columns for the breakpoint\n * @throws Error if breakpoint is not defined in cols\n */\nexport function getColsFromBreakpoint<B extends Breakpoint>(\n  breakpoint: B,\n  cols: Breakpoints<B>\n): number {\n  const colCount = cols[breakpoint];\n  if (colCount === undefined) {\n    throw new Error(\n      `ResponsiveReactGridLayout: \\`cols\\` entry for breakpoint ${String(breakpoint)} is missing!`\n    );\n  }\n  return colCount;\n}\n\n// ============================================================================\n// Layout Generation\n// ============================================================================\n\n/**\n * Find or generate a layout for a breakpoint.\n *\n * If a layout exists for the breakpoint, returns a clone.\n * Otherwise, generates a new layout from the nearest larger breakpoint.\n *\n * @param layouts - Existing layouts by breakpoint\n * @param breakpoints - Breakpoint definitions\n * @param breakpoint - Target breakpoint\n * @param lastBreakpoint - Previous breakpoint (for fallback)\n * @param cols - Column count for the target breakpoint\n * @param compactTypeOrCompactor - Compaction type string (legacy) or Compactor object\n * @returns Layout for the breakpoint\n */\nexport function findOrGenerateResponsiveLayout<B extends Breakpoint>(\n  layouts: ResponsiveLayouts<B>,\n  breakpoints: Breakpoints<B>,\n  breakpoint: B,\n  lastBreakpoint: B,\n  cols: number,\n  compactTypeOrCompactor: CompactType | Compactor\n): Layout {\n  // If it already exists, just return it\n  const existingLayout = layouts[breakpoint];\n  if (existingLayout) {\n    return cloneLayout(existingLayout);\n  }\n\n  // Find or generate the next layout\n  let layout = layouts[lastBreakpoint];\n\n  // Look for layouts at larger breakpoints\n  const breakpointsSorted = sortBreakpoints(breakpoints);\n  const breakpointsAbove = breakpointsSorted.slice(\n    breakpointsSorted.indexOf(breakpoint)\n  );\n\n  for (let i = 0; i < breakpointsAbove.length; i++) {\n    const b = breakpointsAbove[i];\n    if (b === undefined) continue;\n\n    const layoutForBreakpoint = layouts[b];\n    if (layoutForBreakpoint) {\n      layout = layoutForBreakpoint;\n      break;\n    }\n  }\n\n  // Clone layout so we don't modify existing items\n  const clonedLayout = cloneLayout(layout || []);\n\n  // Correct bounds and compact - use compactor.compact() (#2213)\n  // Handle both legacy compactType string and new Compactor object\n  const corrected = correctBounds(clonedLayout, { cols });\n  const compactor: Compactor =\n    typeof compactTypeOrCompactor === \"object\" &&\n    compactTypeOrCompactor !== null\n      ? compactTypeOrCompactor\n      : getCompactor(compactTypeOrCompactor);\n  return compactor.compact(corrected, cols);\n}\n\n// ============================================================================\n// Margin/Padding Helpers\n// ============================================================================\n\ntype IndentationValue<B extends Breakpoint> =\n  | readonly [number, number]\n  | Partial<Record<B, readonly [number, number]>>;\n\n/**\n * Get margin or padding value for a breakpoint.\n *\n * Supports both fixed values ([x, y]) and breakpoint-specific values\n * ({ lg: [x, y], md: [x, y], ... }).\n *\n * @param value - Fixed value or breakpoint-specific map\n * @param breakpoint - Current breakpoint\n * @returns Margin/padding tuple [x, y]\n */\nexport function getIndentationValue<B extends Breakpoint>(\n  value: IndentationValue<B>,\n  breakpoint: B\n): readonly [number, number] {\n  // If it's a tuple (array), return it directly\n  if (Array.isArray(value)) {\n    return value as readonly [number, number];\n  }\n\n  // It's a breakpoint map - find the value\n  const breakpointMap = value as Partial<Record<B, readonly [number, number]>>;\n  const breakpointValue = breakpointMap[breakpoint];\n  if (breakpointValue !== undefined) {\n    return breakpointValue;\n  }\n\n  // Fallback to first defined value\n  const keys = Object.keys(breakpointMap) as B[];\n  for (const key of keys) {\n    const v = breakpointMap[key];\n    if (v !== undefined) {\n      return v;\n    }\n  }\n\n  // Default fallback\n  return [10, 10];\n}\n"]}