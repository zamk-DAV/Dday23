{"version":3,"sources":["../src/extras/GridBackground.tsx","../src/extras/fastVerticalCompactor.ts","../src/extras/fastHorizontalCompactor.ts","../src/extras/wrapCompactor.ts"],"names":["useMemo","calcGridCellDimensions","jsx","cloneLayout","t","cloneLayoutItem","originalIndex"],"mappings":"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","file":"extras.js","sourcesContent":["/**\n * GridBackground component\n *\n * Renders an SVG grid background that aligns with GridLayout cells.\n * Use this to visualize the grid structure behind your layout.\n */\n\nimport * as React from \"react\";\nimport { useMemo } from \"react\";\nimport { calcGridCellDimensions } from \"../core/calculate.js\";\nimport type { GridCellConfig } from \"../core/calculate.js\";\n\nexport interface GridBackgroundProps extends GridCellConfig {\n  /**\n   * Number of rows to display. If \"auto\", calculates based on height.\n   * @default 10\n   */\n  rows?: number | \"auto\";\n\n  /**\n   * Height of the background in pixels. Used when rows=\"auto\".\n   */\n  height?: number;\n\n  /**\n   * Color of the grid cell backgrounds.\n   * @default \"#e0e0e0\"\n   */\n  color?: string;\n\n  /**\n   * Border radius of grid cells in pixels.\n   * @default 4\n   */\n  borderRadius?: number;\n\n  /**\n   * Additional CSS class name.\n   */\n  className?: string;\n\n  /**\n   * Additional inline styles.\n   */\n  style?: React.CSSProperties;\n}\n\n/**\n * SVG grid background component.\n *\n * Renders a visual grid that aligns with GridLayout cells. Position this\n * behind your GridLayout using CSS positioning.\n *\n * @example\n * ```tsx\n * import { GridBackground } from 'react-grid-layout/extras';\n *\n * function MyGrid() {\n *   const { width, containerRef, mounted } = useContainerWidth();\n *\n *   return (\n *     <div ref={containerRef} style={{ position: 'relative' }}>\n *       {mounted && (\n *         <>\n *           <GridBackground\n *             width={width}\n *             cols={12}\n *             rowHeight={30}\n *             margin={[10, 10]}\n *             rows={10}\n *             color=\"#f0f0f0\"\n *           />\n *           <GridLayout width={width} gridConfig={{ cols: 12, rowHeight: 30 }}>\n *             {children}\n *           </GridLayout>\n *         </>\n *       )}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function GridBackground({\n  width,\n  cols,\n  rowHeight,\n  margin = [10, 10],\n  containerPadding,\n  rows = 10,\n  height,\n  color = \"#e0e0e0\",\n  borderRadius = 4,\n  className,\n  style\n}: GridBackgroundProps): React.ReactElement {\n  const dims = useMemo(\n    () =>\n      calcGridCellDimensions({\n        width,\n        cols,\n        rowHeight,\n        margin,\n        containerPadding\n      }),\n    [width, cols, rowHeight, margin, containerPadding]\n  );\n\n  // Calculate number of rows\n  const rowCount = useMemo(() => {\n    if (rows !== \"auto\") return rows;\n    if (height) {\n      // Calculate rows that fit in the given height\n      const padding = containerPadding ?? margin;\n      return Math.ceil(\n        (height - padding[1] * 2 + margin[1]) / (rowHeight + margin[1])\n      );\n    }\n    return 10;\n  }, [rows, height, rowHeight, margin, containerPadding]);\n\n  // Calculate total height\n  const totalHeight = useMemo(() => {\n    const padding = containerPadding ?? margin;\n    return padding[1] * 2 + rowCount * rowHeight + (rowCount - 1) * margin[1];\n  }, [rowCount, rowHeight, margin, containerPadding]);\n\n  // Generate cell rectangles\n  const cells = useMemo(() => {\n    const rects: React.ReactElement[] = [];\n    const { cellWidth, cellHeight, offsetX, offsetY, gapX, gapY } = dims;\n\n    for (let row = 0; row < rowCount; row++) {\n      for (let col = 0; col < cols; col++) {\n        const x = offsetX + col * (cellWidth + gapX);\n        const y = offsetY + row * (cellHeight + gapY);\n\n        rects.push(\n          <rect\n            key={`${row}-${col}`}\n            x={x}\n            y={y}\n            width={cellWidth}\n            height={cellHeight}\n            rx={borderRadius}\n            ry={borderRadius}\n            fill={color}\n          />\n        );\n      }\n    }\n\n    return rects;\n  }, [dims, rowCount, cols, borderRadius, color]);\n\n  return (\n    <svg\n      className={className}\n      style={{\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        width: width,\n        height: totalHeight,\n        pointerEvents: \"none\",\n        ...style\n      }}\n      aria-hidden=\"true\"\n    >\n      {cells}\n    </svg>\n  );\n}\n\nexport default GridBackground;\n","/**\n * Fast Vertical Compactor\n *\n * An optimized vertical compaction algorithm using a \"rising tide\" approach.\n * This algorithm has O(n log n) complexity (dominated by sorting) compared to\n * the default vertical compactor which can have O(n²) complexity due to\n * recursive collision resolution.\n *\n * Best suited for large layouts (200+ items) where compaction performance\n * is critical. For smaller layouts, the difference is negligible.\n *\n * Based on the algorithm from PR #2152 by Morris Brodersen (@morris).\n *\n * @example\n * ```tsx\n * import { fastVerticalCompactor } from 'react-grid-layout/extras';\n *\n * <GridLayout\n *   compactor={fastVerticalCompactor}\n *   layout={layout}\n *   // ...\n * />\n * ```\n */\n\nimport type { Compactor, Layout, LayoutItem, Mutable } from \"../core/types.js\";\nimport { cloneLayout } from \"../core/layout.js\";\n\n/**\n * Check if two layout items collide (overlap).\n */\nfunction collides(l1: LayoutItem, l2: LayoutItem): boolean {\n  if (l1.i === l2.i) return false;\n  return (\n    l1.x < l2.x + l2.w &&\n    l1.x + l1.w > l2.x &&\n    l1.y < l2.y + l2.h &&\n    l1.y + l1.h > l2.y\n  );\n}\n\n/**\n * Fast vertical compaction using a \"rising tide\" algorithm.\n *\n * The algorithm works by:\n * 1. Sorting items by (y, x, static) - top-to-bottom, left-to-right\n * 2. Maintaining a \"tide\" array that tracks the highest occupied row per column\n * 3. For each item, moving it up to meet the tide (closing gaps)\n * 4. Checking for collisions with static items and adjusting as needed\n *\n * This avoids recursive collision resolution, making it O(n log n) overall.\n *\n * @param layout - The layout to compact (will be modified in place)\n * @param cols - Number of columns in the grid\n * @param allowOverlap - Whether to allow overlapping items\n */\nfunction compactVerticalFast(\n  layout: LayoutItem[],\n  cols: number,\n  allowOverlap: boolean\n): void {\n  const numItems = layout.length;\n\n  // Sort items by position: top-to-bottom, left-to-right\n  // Static items are sorted first at each position to reduce collision checks\n  layout.sort((a, b) => {\n    if (a.y < b.y) return -1;\n    if (a.y > b.y) return 1;\n    if (a.x < b.x) return -1;\n    if (a.x > b.x) return 1;\n    // Static items sorted first to reduce collision checks\n    if (a.static && !b.static) return -1;\n    if (!a.static && b.static) return 1;\n    return 0;\n  });\n\n  // \"Rising tide\" - tracks the highest blocked row per column\n  const tide: number[] = new Array(cols).fill(0);\n\n  // Collect static items for collision checking\n  const staticItems = layout.filter(item => item.static);\n  const numStatics = staticItems.length;\n  let staticOffset = 0;\n\n  for (let i = 0; i < numItems; i++) {\n    const item = layout[i] as Mutable<LayoutItem>;\n\n    // Clamp x2 to grid bounds\n    let x2 = item.x + item.w;\n    if (x2 > cols) {\n      x2 = cols;\n    }\n\n    if (item.static) {\n      // Static items don't move; they become part of the tide\n      // and don't need collision checks against themselves\n      ++staticOffset;\n    } else {\n      // Find the minimum gap between the item and the tide\n      let minGap = Infinity;\n      for (let x = item.x; x < x2; ++x) {\n        const tideValue = tide[x] ?? 0;\n        const gap = item.y - tideValue;\n        if (gap < minGap) {\n          minGap = gap;\n        }\n      }\n\n      // Close the gap (move item up to meet the tide)\n      if (!allowOverlap || minGap > 0) {\n        item.y -= minGap;\n      }\n\n      // Handle collisions with static items\n      for (let j = staticOffset; !allowOverlap && j < numStatics; ++j) {\n        const staticItem = staticItems[j];\n        if (staticItem === undefined) continue;\n\n        // Early exit: if static item is below current item, no more collisions possible\n        if (staticItem.y >= item.y + item.h) {\n          break;\n        }\n\n        if (collides(item, staticItem)) {\n          // Move current item below the static item\n          item.y = staticItem.y + staticItem.h;\n\n          if (j > staticOffset) {\n            // Item was moved; need to recheck with earlier static items\n            // Note: j = staticOffset means after ++j we start at staticOffset + 1,\n            // but staticItems[staticOffset] was already checked or is above us\n            j = staticOffset;\n          }\n        }\n      }\n\n      // Reset moved flag\n      item.moved = false;\n    }\n\n    // Update tide: mark columns as blocked up to item's bottom\n    const t = item.y + item.h;\n    for (let x = item.x; x < x2; ++x) {\n      const currentTide = tide[x] ?? 0;\n      if (currentTide < t) {\n        tide[x] = t;\n      }\n    }\n  }\n}\n\n/**\n * Fast vertical compactor - optimized for large layouts.\n *\n * Uses a \"rising tide\" algorithm that achieves O(n log n) complexity\n * instead of the potentially O(n²) recursive collision resolution.\n *\n * Best suited for layouts with 200+ items where compaction performance\n * becomes noticeable. For smaller layouts, the standard verticalCompactor\n * works equally well.\n */\nexport const fastVerticalCompactor: Compactor = {\n  type: \"vertical\",\n  allowOverlap: false,\n\n  compact(layout: Layout, cols: number): Layout {\n    // Clone the layout since we modify in place\n    const out = cloneLayout(layout) as LayoutItem[];\n    compactVerticalFast(out, cols, false);\n    return out;\n  }\n};\n\n/**\n * Fast vertical compactor that allows overlapping items.\n *\n * Compacts items upward but allows them to overlap each other.\n */\nexport const fastVerticalOverlapCompactor: Compactor = {\n  ...fastVerticalCompactor,\n  allowOverlap: true,\n\n  compact(layout: Layout, cols: number): Layout {\n    const out = cloneLayout(layout) as LayoutItem[];\n    compactVerticalFast(out, cols, true);\n    return out;\n  }\n};\n","/**\n * Fast Horizontal Compactor\n *\n * An optimized horizontal compaction algorithm using a \"sweeping tide\" approach.\n * This algorithm has O(n log n) complexity (dominated by sorting) compared to\n * the default horizontal compactor which can have O(n²) complexity due to\n * recursive collision resolution.\n *\n * Best suited for large layouts (200+ items) where compaction performance\n * is critical. For smaller layouts, the difference is negligible.\n *\n * Adapted from the vertical fast compactor algorithm from PR #2152 by Morris Brodersen (@morris).\n *\n * @example\n * ```tsx\n * import { fastHorizontalCompactor } from 'react-grid-layout/extras';\n *\n * <GridLayout\n *   compactor={fastHorizontalCompactor}\n *   layout={layout}\n *   // ...\n * />\n * ```\n */\n\nimport type { Compactor, Layout, LayoutItem, Mutable } from \"../core/types.js\";\nimport { cloneLayout } from \"../core/layout.js\";\n\n/**\n * Ensure the tide array has enough rows.\n */\nfunction ensureTideRows(tide: number[], neededRows: number): void {\n  while (tide.length < neededRows) {\n    tide.push(0);\n  }\n}\n\n/**\n * Find the maximum tide value for a range of rows.\n */\nfunction getMaxTideForItem(tide: number[], y: number, h: number): number {\n  let maxTide = 0;\n  for (let row = y; row < y + h; row++) {\n    const tideValue = tide[row] ?? 0;\n    if (tideValue > maxTide) {\n      maxTide = tideValue;\n    }\n  }\n  return maxTide;\n}\n\n/**\n * Check if an item can be placed at a given position without colliding with static items.\n */\nfunction canPlaceAt(\n  item: LayoutItem,\n  x: number,\n  y: number,\n  staticItems: LayoutItem[],\n  cols: number\n): boolean {\n  // Check grid bounds\n  if (x + item.w > cols) return false;\n\n  // Check static collisions\n  for (const staticItem of staticItems) {\n    if (\n      x < staticItem.x + staticItem.w &&\n      x + item.w > staticItem.x &&\n      y < staticItem.y + staticItem.h &&\n      y + item.h > staticItem.y\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Fast horizontal compaction using a \"sweeping tide\" algorithm with row wrapping.\n *\n * The algorithm works by:\n * 1. Sorting items by (y, x, static) - top-to-bottom, left-to-right (like standard compactor)\n * 2. Maintaining a \"tide\" array that tracks the rightmost occupied column per row\n * 3. For each item, finding the leftmost position it can occupy\n * 4. If the item doesn't fit in its current row, wrapping to the next row\n * 5. Checking for collisions with static items and adjusting as needed\n *\n * This avoids recursive collision resolution, making it O(n log n) overall.\n *\n * @param layout - The layout to compact (will be modified in place)\n * @param cols - Number of columns in the grid\n * @param allowOverlap - Whether to allow overlapping items\n */\nfunction compactHorizontalFast(\n  layout: LayoutItem[],\n  cols: number,\n  allowOverlap: boolean\n): void {\n  const numItems = layout.length;\n  if (numItems === 0) return;\n\n  // Sort items by column then row (same as standard horizontal compactor)\n  // Static items are sorted first at each position to reduce collision checks\n  layout.sort((a, b) => {\n    if (a.x !== b.x) return a.x - b.x;\n    if (a.y !== b.y) return a.y - b.y;\n    if (a.static !== b.static) return a.static ? -1 : 1;\n    return 0;\n  });\n\n  // Calculate max row extent for pre-allocation\n  let maxRow = 0;\n  for (let i = 0; i < numItems; i++) {\n    const item = layout[i];\n    if (item !== undefined) {\n      const bottom = item.y + item.h;\n      if (bottom > maxRow) maxRow = bottom;\n    }\n  }\n\n  // \"Sweeping tide\" - tracks the rightmost blocked column per row\n  // Pre-allocate based on max row extent to avoid repeated reallocations\n  const tide: number[] = new Array(maxRow).fill(0);\n\n  // Collect static items for collision checking\n  const staticItems = layout.filter(item => item.static);\n\n  // Safety limit for row wrapping (prevents infinite loops)\n  // Use a limit relative to layout size (at least 10_000, or 100x the number of items)\n  const maxRowLimit = Math.max(10_000, numItems * 100);\n\n  for (let i = 0; i < numItems; i++) {\n    const item = layout[i] as Mutable<LayoutItem>;\n\n    if (item.static) {\n      // Static items don't move; they become part of the tide\n      ensureTideRows(tide, item.y + item.h);\n      const t = item.x + item.w;\n      for (let y = item.y; y < item.y + item.h; y++) {\n        if ((tide[y] ?? 0) < t) {\n          tide[y] = t;\n        }\n      }\n      continue;\n    }\n\n    // For non-static items, find the best position\n    let targetY = item.y;\n    let targetX = 0;\n    let placed = false;\n\n    // Try to place the item, wrapping to lower rows if needed\n    while (!placed) {\n      ensureTideRows(tide, targetY + item.h);\n\n      // Find the maximum tide across the rows this item spans\n      const maxTide = getMaxTideForItem(tide, targetY, item.h);\n\n      // Try to place at the tide position\n      targetX = maxTide;\n\n      // Check if item fits within grid bounds\n      if (targetX + item.w <= cols) {\n        // Check for static item collisions\n        if (\n          allowOverlap ||\n          canPlaceAt(item, targetX, targetY, staticItems, cols)\n        ) {\n          placed = true;\n        } else {\n          // Find the rightmost static collision and try past it\n          let maxStaticRight = targetX;\n          let foundCollision = false;\n          for (const staticItem of staticItems) {\n            if (\n              targetX < staticItem.x + staticItem.w &&\n              targetX + item.w > staticItem.x &&\n              targetY < staticItem.y + staticItem.h &&\n              targetY + item.h > staticItem.y\n            ) {\n              maxStaticRight = Math.max(\n                maxStaticRight,\n                staticItem.x + staticItem.w\n              );\n              foundCollision = true;\n            }\n          }\n          if (foundCollision) {\n            targetX = maxStaticRight;\n          }\n\n          // After moving past static, check if we still fit\n          if (foundCollision && targetX + item.w <= cols) {\n            // Verify no more collisions at new position\n            if (canPlaceAt(item, targetX, targetY, staticItems, cols)) {\n              placed = true;\n            } else {\n              // Can't fit in this row, wrap to next\n              targetY++;\n            }\n          } else if (foundCollision) {\n            // Pushed past grid edge, wrap to next row\n            targetY++;\n          } else {\n            // No collision but can't place - shouldn't happen\n            placed = true;\n          }\n        }\n      } else {\n        // Doesn't fit in this row, wrap to next\n        targetY++;\n      }\n\n      // Safety check to prevent infinite loops\n      if (targetY > maxRowLimit) {\n        if (typeof console !== \"undefined\" && console.warn) {\n          console.warn(\n            `Fast horizontal compactor: Item \"${item.i}\" exceeded max row limit (${targetY}). ` +\n              `This may indicate a layout that cannot be compacted within grid bounds.`\n          );\n        }\n        // Give up and place at current position\n        targetX = 0;\n        placed = true;\n      }\n    }\n\n    // Update item position\n    item.x = targetX;\n    item.y = targetY;\n    item.moved = false;\n\n    // Update tide: mark rows as blocked up to item's right edge\n    ensureTideRows(tide, targetY + item.h);\n    const t = targetX + item.w;\n    for (let y = targetY; y < targetY + item.h; y++) {\n      if ((tide[y] ?? 0) < t) {\n        tide[y] = t;\n      }\n    }\n  }\n}\n\n/**\n * Fast horizontal compactor - optimized for large layouts.\n *\n * Uses a \"sweeping tide\" algorithm that achieves O(n log n) complexity\n * instead of the potentially O(n²) recursive collision resolution.\n *\n * Best suited for layouts with 200+ items where compaction performance\n * becomes noticeable. For smaller layouts, the standard horizontalCompactor\n * works equally well.\n */\nexport const fastHorizontalCompactor: Compactor = {\n  type: \"horizontal\",\n  allowOverlap: false,\n\n  compact(layout: Layout, cols: number): Layout {\n    // Clone the layout since we modify in place\n    const out = cloneLayout(layout) as LayoutItem[];\n    compactHorizontalFast(out, cols, false);\n    return out;\n  }\n};\n\n/**\n * Fast horizontal compactor that allows overlapping items.\n *\n * Compacts items leftward but allows them to overlap each other.\n */\nexport const fastHorizontalOverlapCompactor: Compactor = {\n  ...fastHorizontalCompactor,\n  allowOverlap: true,\n\n  compact(layout: Layout, cols: number): Layout {\n    const out = cloneLayout(layout) as LayoutItem[];\n    compactHorizontalFast(out, cols, true);\n    return out;\n  }\n};\n","/**\n * Wrap Compactor\n *\n * A compaction algorithm that treats grid items like words in a paragraph.\n * Items flow left-to-right, wrapping to the next row when they reach\n * the grid edge.\n *\n * When dragging:\n * - Moving an item earlier in the sequence shifts other items down/right\n * - Moving an item later in the sequence shifts other items up/left\n *\n * This creates a natural reordering behavior similar to drag-and-drop\n * in file managers or card layouts.\n *\n * Based on the algorithm from PR #1773 by John Thomson (@JohnThomson).\n *\n * @example\n * ```tsx\n * import { wrapCompactor } from 'react-grid-layout/extras';\n *\n * <GridLayout\n *   compactor={wrapCompactor}\n *   layout={layout}\n *   // ...\n * />\n * ```\n */\n\nimport type { Compactor, Layout, LayoutItem, Mutable } from \"../core/types.js\";\nimport { cloneLayout, cloneLayoutItem } from \"../core/layout.js\";\n\n/**\n * Sort items in wrap order: left-to-right, top-to-bottom.\n * This is the visual reading order for wrapped content.\n */\nfunction sortByWrapOrder(layout: Layout): LayoutItem[] {\n  return [...layout].sort((a, b) => {\n    // Primary: top-to-bottom (by row)\n    if (a.y !== b.y) return a.y - b.y;\n    // Secondary: left-to-right (by column)\n    return a.x - b.x;\n  });\n}\n\n/**\n * Convert a linear wrap position back to x,y coordinates.\n */\nfunction fromWrapPosition(pos: number, cols: number): { x: number; y: number } {\n  return {\n    x: pos % cols,\n    y: Math.floor(pos / cols)\n  };\n}\n\n/**\n * Compact items in wrap order, filling gaps from left-to-right, top-to-bottom.\n * All items are assumed to be 1x1 for wrap mode to work correctly.\n */\nfunction compactWrap(layout: Layout, cols: number): LayoutItem[] {\n  if (layout.length === 0) return [];\n\n  const sorted = sortByWrapOrder(layout);\n  const out: LayoutItem[] = new Array(layout.length);\n  const statics = sorted.filter(item => item.static);\n\n  // Track which positions are occupied by static items\n  const staticPositions = new Set<number>();\n  for (const s of statics) {\n    // For static items, mark all cells they occupy\n    for (let dy = 0; dy < s.h; dy++) {\n      for (let dx = 0; dx < s.w; dx++) {\n        staticPositions.add((s.y + dy) * cols + (s.x + dx));\n      }\n    }\n  }\n\n  let nextPos = 0;\n\n  for (let i = 0; i < sorted.length; i++) {\n    const sortedItem = sorted[i];\n    if (sortedItem === undefined) continue;\n\n    const l = cloneLayoutItem(sortedItem);\n\n    if (l.static) {\n      // Static items stay in place\n      const originalIndex = layout.indexOf(sortedItem);\n      out[originalIndex] = l;\n      l.moved = false;\n      continue;\n    }\n\n    // Find next available position that doesn't conflict with statics\n    while (staticPositions.has(nextPos)) {\n      nextPos++;\n    }\n\n    // For items larger than 1x1, we need to check if the full item fits\n    const { x, y } = fromWrapPosition(nextPos, cols);\n\n    // Check if item would overflow the row\n    if (x + l.w > cols) {\n      // Move to start of next row\n      nextPos = (y + 1) * cols;\n      // Skip any static positions on the new row\n      while (staticPositions.has(nextPos)) {\n        nextPos++;\n      }\n    }\n\n    const newCoords = fromWrapPosition(nextPos, cols);\n    (l as Mutable<LayoutItem>).x = newCoords.x;\n    (l as Mutable<LayoutItem>).y = newCoords.y;\n\n    // Advance past this item\n    nextPos += l.w;\n\n    const originalIndex = layout.indexOf(sortedItem);\n    out[originalIndex] = l;\n    l.moved = false;\n  }\n\n  return out;\n}\n\n/**\n * Wrap compactor - arranges items like words in a paragraph.\n *\n * Items flow left-to-right and wrap to the next row when they\n * reach the grid edge. Dragging an item reorders the sequence,\n * with other items shifting to maintain the flow.\n *\n * Works best with uniformly-sized items (especially 1x1), but\n * handles larger items by ensuring they fit within row bounds.\n */\nexport const wrapCompactor: Compactor = {\n  type: \"wrap\",\n  allowOverlap: false,\n\n  compact(layout: Layout, cols: number): Layout {\n    return compactWrap(layout, cols);\n  }\n};\n\n/**\n * Wrap compactor that allows overlapping items.\n */\nexport const wrapOverlapCompactor: Compactor = {\n  ...wrapCompactor,\n  allowOverlap: true,\n\n  compact(layout: Layout, _cols: number): Layout {\n    // With overlap allowed, just clone without compacting\n    return cloneLayout(layout);\n  }\n};\n"]}