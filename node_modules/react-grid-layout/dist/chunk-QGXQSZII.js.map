{"version":3,"sources":["../src/react/hooks/useContainerWidth.ts","../src/react/hooks/useGridLayout.ts","../src/react/hooks/useResponsiveLayout.ts"],"names":["useState","useRef","useCallback","useEffect","verticalCompactor","correctBounds","cloneLayout","deepEqual","getLayoutItem","cloneLayoutItem","moveElement","useMemo","bottom","sortBreakpoints","getBreakpointFromWidth","getColsFromBreakpoint","layout","findOrGenerateResponsiveLayout"],"mappings":"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","file":"chunk-QGXQSZII.js","sourcesContent":["/**\n * useContainerWidth hook\n *\n * Observes container width using ResizeObserver and provides\n * reactive width updates for responsive layouts.\n */\n\nimport {\n  useState,\n  useEffect,\n  useRef,\n  useCallback,\n  type RefObject\n} from \"react\";\n\nexport interface UseContainerWidthOptions {\n  /**\n   * If true, delays initial render until width is measured.\n   * Useful for SSR or when you need accurate initial measurements.\n   */\n  measureBeforeMount?: boolean;\n\n  /**\n   * Initial width to use before measurement.\n   * Defaults to 1280.\n   */\n  initialWidth?: number;\n}\n\nexport interface UseContainerWidthResult {\n  /**\n   * Current container width in pixels.\n   */\n  width: number;\n\n  /**\n   * Whether the container has been measured at least once.\n   */\n  mounted: boolean;\n\n  /**\n   * Ref to attach to the container element.\n   */\n  containerRef: RefObject<HTMLDivElement | null>;\n\n  /**\n   * Manually trigger a width measurement.\n   * Useful when the container size might change without a resize event.\n   */\n  measureWidth: () => void;\n}\n\n/**\n * Hook to observe and track container width.\n *\n * Replaces the WidthProvider HOC with a more composable approach.\n *\n * @example\n * ```tsx\n * function MyGrid() {\n *   const { width, containerRef, mounted } = useContainerWidth();\n *\n *   return (\n *     <div ref={containerRef}>\n *       {mounted && <GridLayout width={width} {...props} />}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useContainerWidth(\n  options: UseContainerWidthOptions = {}\n): UseContainerWidthResult {\n  const { measureBeforeMount = false, initialWidth = 1280 } = options;\n\n  const [width, setWidth] = useState(initialWidth);\n  const [mounted, setMounted] = useState(!measureBeforeMount);\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const observerRef = useRef<ResizeObserver | null>(null);\n\n  const measureWidth = useCallback(() => {\n    const node = containerRef.current;\n    if (node) {\n      const newWidth = node.offsetWidth;\n      setWidth(newWidth);\n      if (!mounted) {\n        setMounted(true);\n      }\n    }\n  }, [mounted]);\n\n  useEffect(() => {\n    const node = containerRef.current;\n    if (!node) return;\n\n    // Initial measurement\n    measureWidth();\n\n    // Set up ResizeObserver\n    if (typeof ResizeObserver !== \"undefined\") {\n      observerRef.current = new ResizeObserver(entries => {\n        const entry = entries[0];\n        if (entry) {\n          // Use contentRect.width for consistent measurements\n          const newWidth = entry.contentRect.width;\n          setWidth(newWidth);\n        }\n      });\n\n      observerRef.current.observe(node);\n    }\n\n    return () => {\n      if (observerRef.current) {\n        observerRef.current.disconnect();\n        observerRef.current = null;\n      }\n    };\n  }, [measureWidth]);\n\n  return {\n    width,\n    mounted,\n    containerRef,\n    measureWidth\n  };\n}\n\nexport default useContainerWidth;\n","/**\n * useGridLayout hook\n *\n * Core hook for managing grid layout state, including drag, resize, and drop operations.\n * This extracts the state management logic from ReactGridLayout into a reusable hook.\n */\n\nimport { useState, useCallback, useMemo, useRef, useEffect } from \"react\";\nimport { deepEqual } from \"fast-equals\";\nimport type {\n  Layout,\n  LayoutItem,\n  DroppingPosition,\n  Compactor,\n  Mutable\n} from \"../../core/types.js\";\nimport {\n  cloneLayout,\n  cloneLayoutItem,\n  moveElement,\n  correctBounds,\n  bottom,\n  getLayoutItem\n} from \"../../core/layout.js\";\nimport { verticalCompactor } from \"../../core/compactors.js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface DragState {\n  /** Currently dragging item placeholder */\n  activeDrag: LayoutItem | null;\n  /** Original item before drag started */\n  oldDragItem: LayoutItem | null;\n  /** Layout before drag started */\n  oldLayout: Layout | null;\n}\n\nexport interface ResizeState {\n  /** Whether a resize is in progress */\n  resizing: boolean;\n  /** Original item before resize started */\n  oldResizeItem: LayoutItem | null;\n  /** Layout before resize started */\n  oldLayout: Layout | null;\n}\n\nexport interface DropState {\n  /** DOM node for the dropping placeholder */\n  droppingDOMNode: React.ReactElement | null;\n  /** Current drop position */\n  droppingPosition: DroppingPosition | null;\n}\n\nexport interface UseGridLayoutOptions {\n  /** Initial layout */\n  layout: Layout;\n  /** Number of columns */\n  cols: number;\n  /** Prevent collisions when moving items */\n  preventCollision?: boolean;\n  /** Called when layout changes */\n  onLayoutChange?: (layout: Layout) => void;\n  /** Compactor for layout compaction (default: verticalCompactor) */\n  compactor?: Compactor;\n}\n\nexport interface UseGridLayoutResult {\n  /** Current layout */\n  layout: Layout;\n  /** Set layout directly */\n  setLayout: (layout: Layout) => void;\n  /** Drag state */\n  dragState: DragState;\n  /** Resize state */\n  resizeState: ResizeState;\n  /** Drop state */\n  dropState: DropState;\n  /** Start dragging an item */\n  onDragStart: (itemId: string, x: number, y: number) => LayoutItem | null;\n  /** Update drag position */\n  onDrag: (itemId: string, x: number, y: number) => void;\n  /** Stop dragging */\n  onDragStop: (itemId: string, x: number, y: number) => void;\n  /** Start resizing an item */\n  onResizeStart: (itemId: string) => LayoutItem | null;\n  /** Update resize dimensions */\n  onResize: (\n    itemId: string,\n    w: number,\n    h: number,\n    x?: number,\n    y?: number\n  ) => void;\n  /** Stop resizing */\n  onResizeStop: (itemId: string, w: number, h: number) => void;\n  /** Start dropping (external drag-in) */\n  onDropDragOver: (\n    droppingItem: LayoutItem,\n    position: DroppingPosition\n  ) => void;\n  /** Update drop position */\n  onDropDragLeave: () => void;\n  /** Complete drop */\n  onDrop: (droppingItem: LayoutItem) => void;\n  /** Container height in rows */\n  containerHeight: number;\n  /** Whether any drag/resize is active */\n  isInteracting: boolean;\n  /** Get the compactor being used */\n  compactor: Compactor;\n}\n\n// ============================================================================\n// Hook Implementation\n// ============================================================================\n\n/**\n * Hook for managing grid layout state.\n *\n * Handles all layout state including drag, resize, and drop operations.\n * Uses immutable updates and provides callbacks for all interactions.\n *\n * @example\n * ```tsx\n * function MyGrid() {\n *   const {\n *     layout,\n *     onDragStart,\n *     onDrag,\n *     onDragStop,\n *     containerHeight\n *   } = useGridLayout({\n *     layout: initialLayout,\n *     cols: 12\n *   });\n *\n *   return (\n *     <div style={{ height: containerHeight }}>\n *       {layout.map(item => (\n *         <GridItem\n *           key={item.i}\n *           {...item}\n *           onDragStart={() => onDragStart(item.i, item.x, item.y)}\n *         />\n *       ))}\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useGridLayout(\n  options: UseGridLayoutOptions\n): UseGridLayoutResult {\n  const {\n    layout: propsLayout,\n    cols,\n    preventCollision = false,\n    onLayoutChange,\n    compactor = verticalCompactor\n  } = options;\n\n  // Track if we're currently dragging to block prop updates\n  const isDraggingRef = useRef(false);\n\n  // Initialize layout with compaction using the compactor\n  const [layout, setLayoutState] = useState<Layout>(() => {\n    const corrected = correctBounds(cloneLayout(propsLayout), { cols });\n    return compactor.compact(corrected, cols);\n  });\n\n  // Drag state\n  const [dragState, setDragState] = useState<DragState>({\n    activeDrag: null,\n    oldDragItem: null,\n    oldLayout: null\n  });\n\n  // Resize state\n  const [resizeState, setResizeState] = useState<ResizeState>({\n    resizing: false,\n    oldResizeItem: null,\n    oldLayout: null\n  });\n\n  // Drop state\n  const [dropState, setDropState] = useState<DropState>({\n    droppingDOMNode: null,\n    droppingPosition: null\n  });\n\n  // Track previous layout for change detection\n  const prevLayoutRef = useRef<Layout>(layout);\n\n  // Set layout with optional compaction - use compactor.compact() (#2213)\n  const setLayout = useCallback(\n    (newLayout: Layout) => {\n      const corrected = correctBounds(cloneLayout(newLayout), { cols });\n      const compacted = compactor.compact(corrected, cols);\n      setLayoutState(compacted);\n    },\n    [cols, compactor]\n  );\n\n  // Sync layout from props when not dragging\n  useEffect(() => {\n    if (isDraggingRef.current) return;\n\n    if (!deepEqual(propsLayout, prevLayoutRef.current)) {\n      setLayout(propsLayout);\n    }\n  }, [propsLayout, setLayout]);\n\n  // Notify layout changes\n  useEffect(() => {\n    if (!deepEqual(layout, prevLayoutRef.current)) {\n      prevLayoutRef.current = layout;\n      onLayoutChange?.(layout);\n    }\n  }, [layout, onLayoutChange]);\n\n  // ============================================================================\n  // Drag Handlers\n  // ============================================================================\n\n  const onDragStart = useCallback(\n    (itemId: string, x: number, y: number): LayoutItem | null => {\n      const item = getLayoutItem(layout, itemId);\n      if (!item) return null;\n\n      isDraggingRef.current = true;\n\n      const placeholder: LayoutItem = {\n        ...cloneLayoutItem(item),\n        x,\n        y,\n        static: false,\n        moved: false\n      };\n\n      setDragState({\n        activeDrag: placeholder,\n        oldDragItem: cloneLayoutItem(item),\n        oldLayout: cloneLayout(layout)\n      });\n\n      return placeholder;\n    },\n    [layout]\n  );\n\n  const onDrag = useCallback(\n    (itemId: string, x: number, y: number) => {\n      const item = getLayoutItem(layout, itemId);\n      if (!item) return;\n\n      // Update placeholder position\n      setDragState(prev => ({\n        ...prev,\n        activeDrag: prev.activeDrag ? { ...prev.activeDrag, x, y } : null\n      }));\n\n      // Move element and update layout\n      const newLayout = moveElement(\n        layout,\n        item,\n        x,\n        y,\n        true, // isUserAction\n        preventCollision,\n        compactor.type,\n        cols,\n        compactor.allowOverlap\n      );\n\n      // Compact layout - use compactor.compact() (#2213)\n      const compacted = compactor.compact(newLayout, cols);\n\n      setLayoutState(compacted);\n    },\n    [layout, cols, compactor, preventCollision]\n  );\n\n  const onDragStop = useCallback(\n    (itemId: string, x: number, y: number) => {\n      const item = getLayoutItem(layout, itemId);\n      if (!item) return;\n\n      // Final move\n      const newLayout = moveElement(\n        layout,\n        item,\n        x,\n        y,\n        true,\n        preventCollision,\n        compactor.type,\n        cols,\n        compactor.allowOverlap\n      );\n\n      // Compact and finalize - use compactor.compact() (#2213)\n      const compacted = compactor.compact(newLayout, cols);\n\n      isDraggingRef.current = false;\n\n      setDragState({\n        activeDrag: null,\n        oldDragItem: null,\n        oldLayout: null\n      });\n\n      setLayoutState(compacted);\n    },\n    [layout, cols, compactor, preventCollision]\n  );\n\n  // ============================================================================\n  // Resize Handlers\n  // ============================================================================\n\n  const onResizeStart = useCallback(\n    (itemId: string): LayoutItem | null => {\n      const item = getLayoutItem(layout, itemId);\n      if (!item) return null;\n\n      setResizeState({\n        resizing: true,\n        oldResizeItem: cloneLayoutItem(item),\n        oldLayout: cloneLayout(layout)\n      });\n\n      return item;\n    },\n    [layout]\n  );\n\n  const onResize = useCallback(\n    (itemId: string, w: number, h: number, x?: number, y?: number) => {\n      const newLayout = layout.map(item => {\n        if (item.i === itemId) {\n          const updated: LayoutItem = {\n            ...item,\n            w,\n            h\n          };\n          if (x !== undefined) (updated as Mutable<LayoutItem>).x = x;\n          if (y !== undefined) (updated as Mutable<LayoutItem>).y = y;\n          return updated;\n        }\n        return item;\n      });\n\n      // Correct bounds and compact - use compactor.compact() (#2213)\n      const corrected = correctBounds(newLayout, { cols });\n      const compacted = compactor.compact(corrected, cols);\n\n      setLayoutState(compacted);\n    },\n    [layout, cols, compactor]\n  );\n\n  const onResizeStop = useCallback(\n    (itemId: string, w: number, h: number) => {\n      // Apply final resize\n      onResize(itemId, w, h);\n\n      setResizeState({\n        resizing: false,\n        oldResizeItem: null,\n        oldLayout: null\n      });\n    },\n    [onResize]\n  );\n\n  // ============================================================================\n  // Drop Handlers\n  // ============================================================================\n\n  const onDropDragOver = useCallback(\n    (droppingItem: LayoutItem, position: DroppingPosition) => {\n      // Check if item already exists in layout\n      const existingItem = getLayoutItem(layout, droppingItem.i);\n\n      if (!existingItem) {\n        // Add dropping item to layout - use compactor.compact() (#2213)\n        const newLayout = [...layout, droppingItem];\n        const corrected = correctBounds(newLayout, { cols });\n        const compacted = compactor.compact(corrected, cols);\n        setLayoutState(compacted);\n      }\n\n      setDropState({\n        droppingDOMNode: null, // Will be set by component\n        droppingPosition: position\n      });\n    },\n    [layout, cols, compactor]\n  );\n\n  const onDropDragLeave = useCallback(() => {\n    // Remove dropping placeholder from layout\n    const newLayout = layout.filter(item => item.i !== \"__dropping-elem__\");\n    setLayoutState(newLayout);\n\n    setDropState({\n      droppingDOMNode: null,\n      droppingPosition: null\n    });\n  }, [layout]);\n\n  const onDrop = useCallback(\n    (droppingItem: LayoutItem) => {\n      // Replace placeholder with actual item\n      const newLayout = layout.map(item => {\n        if (item.i === \"__dropping-elem__\") {\n          return {\n            ...item,\n            i: droppingItem.i,\n            static: false\n          };\n        }\n        return item;\n      });\n\n      // Use compactor.compact() (#2213)\n      const corrected = correctBounds(newLayout, { cols });\n      const compacted = compactor.compact(corrected, cols);\n      setLayoutState(compacted);\n\n      setDropState({\n        droppingDOMNode: null,\n        droppingPosition: null\n      });\n    },\n    [layout, cols, compactor]\n  );\n\n  // ============================================================================\n  // Computed Values\n  // ============================================================================\n\n  const containerHeight = useMemo(() => bottom(layout), [layout]);\n\n  const isInteracting =\n    dragState.activeDrag !== null ||\n    resizeState.resizing ||\n    dropState.droppingPosition !== null;\n\n  return {\n    layout,\n    setLayout,\n    dragState,\n    resizeState,\n    dropState,\n    onDragStart,\n    onDrag,\n    onDragStop,\n    onResizeStart,\n    onResize,\n    onResizeStop,\n    onDropDragOver,\n    onDropDragLeave,\n    onDrop,\n    containerHeight,\n    isInteracting,\n    compactor\n  };\n}\n\nexport default useGridLayout;\n","/**\n * useResponsiveLayout hook\n *\n * Manages responsive breakpoints and layout generation for different screen sizes.\n * Extracts state management from ResponsiveReactGridLayout into a reusable hook.\n */\n\nimport { useState, useCallback, useEffect, useMemo, useRef } from \"react\";\nimport { deepEqual } from \"fast-equals\";\nimport type {\n  Layout,\n  Breakpoint,\n  Breakpoints,\n  ResponsiveLayouts,\n  Compactor\n} from \"../../core/types.js\";\nimport { cloneLayout } from \"../../core/layout.js\";\nimport {\n  getBreakpointFromWidth,\n  getColsFromBreakpoint,\n  findOrGenerateResponsiveLayout,\n  sortBreakpoints\n} from \"../../core/responsive.js\";\nimport { verticalCompactor } from \"../../core/compactors.js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\n/** Default breakpoint names */\nexport type DefaultBreakpoints = \"lg\" | \"md\" | \"sm\" | \"xs\" | \"xxs\";\n\n/** Default breakpoint widths */\nexport const DEFAULT_BREAKPOINTS: Breakpoints<DefaultBreakpoints> = {\n  lg: 1200,\n  md: 996,\n  sm: 768,\n  xs: 480,\n  xxs: 0\n};\n\n/** Default column counts per breakpoint */\nexport const DEFAULT_COLS: Breakpoints<DefaultBreakpoints> = {\n  lg: 12,\n  md: 10,\n  sm: 6,\n  xs: 4,\n  xxs: 2\n};\n\nexport interface UseResponsiveLayoutOptions<\n  B extends Breakpoint = DefaultBreakpoints\n> {\n  /** Current container width */\n  width: number;\n  /** Breakpoint definitions (name â†’ min-width) */\n  breakpoints?: Breakpoints<B>;\n  /** Column counts per breakpoint */\n  cols?: Breakpoints<B>;\n  /** Layouts for each breakpoint */\n  layouts?: ResponsiveLayouts<B>;\n  /** Compactor for layout compaction (default: verticalCompactor) */\n  compactor?: Compactor;\n  /** Called when breakpoint changes */\n  onBreakpointChange?: (newBreakpoint: B, cols: number) => void;\n  /** Called when layout changes */\n  onLayoutChange?: (layout: Layout, layouts: ResponsiveLayouts<B>) => void;\n  /** Called when width changes */\n  onWidthChange?: (\n    width: number,\n    margin: readonly [number, number],\n    cols: number,\n    containerPadding: readonly [number, number] | null\n  ) => void;\n}\n\nexport interface UseResponsiveLayoutResult<\n  B extends Breakpoint = DefaultBreakpoints\n> {\n  /** Current layout for the active breakpoint */\n  layout: Layout;\n  /** All layouts by breakpoint */\n  layouts: ResponsiveLayouts<B>;\n  /** Current active breakpoint */\n  breakpoint: B;\n  /** Column count for the current breakpoint */\n  cols: number;\n  /** Update layouts for a specific breakpoint */\n  setLayoutForBreakpoint: (breakpoint: B, layout: Layout) => void;\n  /** Update all layouts */\n  setLayouts: (layouts: ResponsiveLayouts<B>) => void;\n  /** Sorted array of breakpoint names (smallest to largest) */\n  sortedBreakpoints: B[];\n}\n\n// ============================================================================\n// Hook Implementation\n// ============================================================================\n\n/**\n * Hook for managing responsive grid layouts.\n *\n * Automatically selects the appropriate layout based on container width\n * and generates layouts for new breakpoints from existing ones.\n *\n * @example\n * ```tsx\n * function MyResponsiveGrid() {\n *   const { width, containerRef } = useContainerWidth();\n *   const { layout, breakpoint, cols } = useResponsiveLayout({\n *     width,\n *     layouts: {\n *       lg: [...],\n *       md: [...],\n *       sm: [...]\n *     }\n *   });\n *\n *   return (\n *     <div ref={containerRef}>\n *       <GridLayout\n *         width={width}\n *         cols={cols}\n *         layout={layout}\n *       />\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useResponsiveLayout<B extends Breakpoint = DefaultBreakpoints>(\n  options: UseResponsiveLayoutOptions<B>\n): UseResponsiveLayoutResult<B> {\n  const {\n    width,\n    breakpoints = DEFAULT_BREAKPOINTS as unknown as Breakpoints<B>,\n    cols: colsConfig = DEFAULT_COLS as unknown as Breakpoints<B>,\n    layouts: propsLayouts = {} as ResponsiveLayouts<B>,\n    compactor = verticalCompactor,\n    onBreakpointChange,\n    onLayoutChange,\n    onWidthChange\n  } = options;\n\n  // Sorted breakpoints for consistent ordering\n  const sortedBreakpoints = useMemo(\n    () => sortBreakpoints(breakpoints),\n    [breakpoints]\n  );\n\n  // Calculate initial breakpoint and cols\n  const initialBreakpoint = useMemo(\n    () => getBreakpointFromWidth(breakpoints, width),\n    // Only calculate on mount, not on width changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  const initialCols = useMemo(\n    () => getColsFromBreakpoint(initialBreakpoint, colsConfig),\n    [initialBreakpoint, colsConfig]\n  );\n\n  // State\n  const [breakpoint, setBreakpoint] = useState<B>(initialBreakpoint);\n  const [cols, setCols] = useState<number>(initialCols);\n  const [layouts, setLayoutsState] = useState<ResponsiveLayouts<B>>(() => {\n    // Clone initial layouts\n    const cloned = {} as ResponsiveLayouts<B>;\n    for (const bp of sortedBreakpoints) {\n      const layout = propsLayouts[bp];\n      if (layout) {\n        (cloned as Record<B, Layout>)[bp] = cloneLayout(layout);\n      }\n    }\n    return cloned;\n  });\n\n  // Track previous values for change detection\n  const prevWidthRef = useRef(width);\n  const prevBreakpointRef = useRef(breakpoint);\n  // Separate refs for props vs state to prevent infinite loops (#2202)\n  // When using inline objects for layouts prop, we need to compare props to props\n  // and state to state, not mix them up.\n  const prevPropsLayoutsRef = useRef(propsLayouts);\n  const prevLayoutsRef = useRef(layouts);\n\n  // Current layout for the active breakpoint - use compactor (#2213)\n  const layout = useMemo(() => {\n    return findOrGenerateResponsiveLayout(\n      layouts,\n      breakpoints,\n      breakpoint,\n      prevBreakpointRef.current,\n      cols,\n      compactor\n    );\n  }, [layouts, breakpoints, breakpoint, cols, compactor]);\n\n  // Set layout for a specific breakpoint\n  const setLayoutForBreakpoint = useCallback((bp: B, newLayout: Layout) => {\n    setLayoutsState((prev: ResponsiveLayouts<B>) => ({\n      ...prev,\n      [bp]: cloneLayout(newLayout)\n    }));\n  }, []);\n\n  // Set all layouts\n  const setLayouts = useCallback((newLayouts: ResponsiveLayouts<B>) => {\n    const cloned = {} as ResponsiveLayouts<B>;\n    for (const bp of Object.keys(newLayouts) as B[]) {\n      const layoutForBp = newLayouts[bp];\n      if (layoutForBp) {\n        (cloned as Record<B, Layout>)[bp] = cloneLayout(layoutForBp);\n      }\n    }\n    setLayoutsState(cloned);\n  }, []);\n\n  // Handle width changes\n  useEffect(() => {\n    if (prevWidthRef.current === width) return;\n    prevWidthRef.current = width;\n\n    // Determine new breakpoint\n    const newBreakpoint = getBreakpointFromWidth(breakpoints, width);\n    const newCols = getColsFromBreakpoint(newBreakpoint, colsConfig);\n\n    // Notify width change\n    onWidthChange?.(width, [10, 10], newCols, null);\n\n    // Check if breakpoint changed\n    if (newBreakpoint !== breakpoint) {\n      // Generate layout for new breakpoint\n      // Use compactor (#2213)\n      const newLayout = findOrGenerateResponsiveLayout(\n        layouts,\n        breakpoints,\n        newBreakpoint,\n        breakpoint,\n        newCols,\n        compactor\n      );\n\n      // Update layouts with the new breakpoint layout\n      const updatedLayouts: ResponsiveLayouts<B> = {\n        ...layouts,\n        [newBreakpoint]: newLayout\n      };\n\n      setLayoutsState(updatedLayouts);\n      setBreakpoint(newBreakpoint);\n      setCols(newCols);\n\n      // Notify breakpoint change\n      onBreakpointChange?.(newBreakpoint, newCols);\n\n      prevBreakpointRef.current = newBreakpoint;\n    }\n  }, [\n    width,\n    breakpoints,\n    colsConfig,\n    breakpoint,\n    layouts,\n    compactor,\n    onBreakpointChange,\n    onWidthChange\n  ]);\n\n  // Sync with prop layouts when they change\n  useEffect(() => {\n    if (!deepEqual(propsLayouts, prevPropsLayoutsRef.current)) {\n      setLayouts(propsLayouts);\n      prevPropsLayoutsRef.current = propsLayouts;\n    }\n  }, [propsLayouts, setLayouts]);\n\n  // Notify layout changes\n  useEffect(() => {\n    if (!deepEqual(layouts, prevLayoutsRef.current)) {\n      prevLayoutsRef.current = layouts;\n      onLayoutChange?.(layout, layouts);\n    }\n  }, [layout, layouts, onLayoutChange]);\n\n  return {\n    layout,\n    layouts,\n    breakpoint,\n    cols,\n    setLayoutForBreakpoint,\n    setLayouts,\n    sortedBreakpoints\n  };\n}\n\nexport default useResponsiveLayout;\n"]}